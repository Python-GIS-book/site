

<!DOCTYPE html>


<html lang="en" data-content_root="" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>Network analysis in Python</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
<link href="../../../_static/styles/bootstrap.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />

  
  <link href="../../../_static/vendor/fontawesome/6.5.1/css/all.min.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.5.1/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.5.1/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.5.1/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" href="../../../_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/css/pythongis.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/css/custom-toggle-button.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/bootstrap.js?digest=8d27b9dea8ad943066ae" />
<link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=8d27b9dea8ad943066ae" />
  <script src="../../../_static/vendor/fontawesome/6.5.1/js/all.min.js?digest=8d27b9dea8ad943066ae"></script>

    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'part2/chapter-09/md/xx-network-analysis';</script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a id="pst-skip-link" class="skip-link" href="#main-content">Skip to main content</a>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>
    Back to top
  </button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <header class="bd-header navbar navbar-expand-lg bd-navbar">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  

<a class="navbar-brand logo" href="../../../index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../../_static/pythongis-logo.png" class="logo__image only-light" alt=" - Home"/>
    <script>document.write(`<img src="../../../_static/pythongis-logo.png" class="logo__image only-dark" alt=" - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Part I - Python essentials</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../part1/chapter-01/index.html">1: Getting started</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-1"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-01/nb/00-motivation.html">Motivation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-01/nb/01-computers-and-programs.html">Computers and programs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-01/nb/02-why-python.html">Why Python?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-01/nb/03-writing-and-running-python-code.html">Writing and running Python code</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-01/nb/04-using-jupyterlab.html">Using JupyterLab for writing code</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-01/nb/05-quick-start.html">Quickly getting started (without installing Python)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-01/nb/06-installation.html">Installing Python and adding libraries</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../part1/chapter-02/index.html">2: Basic programming concepts</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-2"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-02/nb/00-python-basics.html">Basic elements of Python</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-02/nb/01-for-loops.html">for loops</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-02/nb/02-conditional-statements.html">Conditional statements</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-02/nb/03-functions.html">Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-02/nb/04-writing-scripts.html">Writing script files</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-02/nb/05-modules.html">Loading and using modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-02/nb/06-exercises.html">Exercises</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../part1/chapter-03/index.html">3: Introduction to data analysis</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-3"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-03/nb/00-pandas-basics.html">Getting started with data analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-03/nb/01-data-manipulation.html">Common tabular operations in pandas</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-03/nb/02-data-analysis.html">Data wrangling, grouping and aggregation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-03/nb/03-temporal-data.html">Working with temporal data</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-03/nb/04-exercises.html">Exercises</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../part1/chapter-04/index.html">4: Introduction to data visualization</a><input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-4"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-04/nb/00-plotting-in-python.html">Plotting in Python</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-04/nb/01-basic-plotting.html">Plotting with pandas and matplotlib</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-04/nb/02-subplots.html">Creating subplots</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-04/nb/03-plot-formatting.html">Effective plot design: line plots</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-04/nb/04-exercises.html">Exercises</a></li>
</ul>
</li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Part II - Introduction to GIS with Python</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../../chapter-05/index.html">5: Getting started</a><input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-5"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../chapter-05/nb/00-motivation-to-use-python-for-gis.html">Motivation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter-05/nb/01-introduction-to-geographic-data-in-python.html">Geographic data in Python</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter-05/nb/02-introduction-to-coordinate-reference-systems.html">Coordinate reference systems</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../chapter-06/index.html">6: Vector data processing</a><input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-6"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../chapter-06/nb/00-introduction-to-geographic-objects.html">Introduction to geographic data objects in Python</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter-06/nb/01-introduction-to-geopandas.html">Introduction to spatial data analysis with geopandas</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter-06/nb/02-data-io.html">Preparing GeoDataFrames from geographic data</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter-06/nb/03-geometric-manipulation.html">Geometric data manipulations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter-06/nb/04-coordinate-reference-system.html">Working with Map Projections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter-06/nb/05-geocoding.html">Geocoding</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter-06/nb/06-operations-between-multiple-datasets.html">Operations between multiple datasets</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter-06/nb/07-exercises.html">Exercises</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../chapter-07/index.html">7: Raster data processing</a><input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-7"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../chapter-07/nb/00-introduction-to-raster-analysis.html">Introduction to raster processing with Python</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter-07/nb/01-reading-raster.html">Reading raster files</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter-07/nb/02-common-raster-operations.html">Common raster operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter-07/nb/03-raster-operations-between-multiple-layers.html">Raster operations between multiple layers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter-07/nb/04-exercises.html">Exercises</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../chapter-08/index.html">8: Geographic data visualization</a><input class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-8"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../chapter-08/nb/00-introduction-to-geographic-visualization.html">Introduction to geographic visualization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter-08/nb/01-static-vector-maps.html">Static maps</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter-08/nb/02-static-raster-maps.html">Visualizing raster layers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter-08/nb/03-interactive-maps.html">Interactive maps</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter-08/nb/04-map-design-principles-and-colors.html">Designing maps</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter-08/nb/05-exercises.html">Exercises</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../index.html">9: Using online geographic data sources</a><input class="toctree-checkbox" id="toctree-checkbox-9" name="toctree-checkbox-9" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-9"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../nb/00-retrieving-osm-data.html">Retrieving OpenStreetMap data</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nb/01-retrieving-data-from-wfs.html">Retrieving data from Web Feature Service (WFS)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nb/02-retrieving-data-from-wcs.html">Retrieving data from Web Coverage Service (WCS)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nb/03-read-data-from-spatial-databases.html">Reading data from spatial databases</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nb/04-exercises.html">Exercises</a></li>
</ul>
</li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Part III - Case studies</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../part3/chapter-10/index.html">10: Spatial interpolation</a><input class="toctree-checkbox" id="toctree-checkbox-10" name="toctree-checkbox-10" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-10"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../part3/chapter-10/nb/00-introduction-to-spatial-interpolation.html">Introduction to spatial interpolation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part3/chapter-10/nb/01-inverse-distance-weighting.html">Inverse Distance Weighting interpolation with Python</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part3/chapter-10/nb/02-exercises.html">Exercises</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../part3/chapter-11/index.html">11: Spatial network analysis</a><input class="toctree-checkbox" id="toctree-checkbox-11" name="toctree-checkbox-11" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-11"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../part3/chapter-11/nb/00-introduction-to-spatial-network-analysis.html">Introduction to spatial network analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part3/chapter-11/nb/02-multimodal-spatial-accessibility-modelling.html">Multimodal spatial accessibility analysis with Python</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part3/chapter-11/nb/03-exercises.html">Exercises</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../part3/chapter-12/index.html">12: Terrain analysis</a><input class="toctree-checkbox" id="toctree-checkbox-12" name="toctree-checkbox-12" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-12"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../part3/chapter-12/nb/00-introduction-to-terrain-analysis.html">Introduction to terrain analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part3/chapter-12/nb/01-interpreting-topographic-features.html">Interpreting topographic features from raster data</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part3/chapter-12/nb/02-exercises.html">Exercises</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../part3/chapter-13/index.html">13: Conclusions</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Back matter</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../../back-matter/nb/acknowledgements.html">Acknowledgements</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../back-matter/appendices.html">Appendices</a><input class="toctree-checkbox" id="toctree-checkbox-13" name="toctree-checkbox-13" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-13"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../back-matter/nb/appendix-1.html">Version control with git</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../back-matter/nb/appendix-2.html">Collaborative coding with GitHub</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../back-matter/nb/appendix-3.html">Using Python script files</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../back-matter/nb/appendix-4.html">Testing and debugging your code</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../back-matter/nb/appendix-5.html">Solutions to questions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../back-matter/nb/appendix-6.html">Exercise solutions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../back-matter/nb/glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../back-matter/nb/references.html">References</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../authors.html">About the authors</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Datasets</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../../data/index.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../data/noaa-data.html">NOAA Weather data</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">


<a href="https://github.com/Python-GIS-book/site/edit/main/part2/chapter-09/md/xx-network-analysis.md" target="_blank"
   class="btn btn-sm btn-source-edit-button"
   title="Suggest edit"
   data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-pencil-alt"></i>
  </span>

</a>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../../../_sources/part2/chapter-09/md/xx-network-analysis.md" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.md</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm navbar-btn theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch nav-link" data-mode="light"><i class="fa-solid fa-sun fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="dark"><i class="fa-solid fa-moon fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="auto"><i class="fa-solid fa-circle-half-stroke fa-lg"></i></span>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Network analysis in Python</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#get-the-network">Get the network</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#analyzing-the-network-properties">Analyzing the network properties</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#shortest-path-analysis">Shortest path analysis</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#origin-and-destination-points">Origin and destination points</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#nearest-node">Nearest node</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#routing">Routing</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#saving-shortest-paths-to-disk">Saving shortest paths to disk</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section id="network-analysis-in-python">
<h1>Network analysis in Python<a class="headerlink" href="#network-analysis-in-python" title="Permalink to this heading">#</a></h1>
<p>Finding a shortest path using a specific street network is a common GIS problem that has many practical
applications. For example navigators are one of those “every-day” applications where <strong>routing</strong> using specific algorithms is used to find the optimal route between two (or multiple) points.</p>
<p>It is also possible to perform network analysis such as tranposrtation routing in Python.
<a class="reference external" href="https://networkx.github.io/documentation/stable/">Networkx</a> is a Python module that provides tools for analyzing networks in various different ways. It also contains algorithms
such as <a class="reference external" href="https://networkx.github.io/documentation/networkx-1.10/reference/generated/networkx.algorithms.shortest_paths.weighted.single_source_dijkstra.html#networkx.algorithms.shortest_paths.weighted.single_source_dijkstra">Dijkstra’s algorithm</a> or
<a class="reference external" href="https://networkx.github.io/documentation/networkx-1.10/reference/generated/networkx.algorithms.shortest_paths.astar.astar_path.html#networkx.algorithms.shortest_paths.astar.astar_path">A*</a> algoritm that are commonly used to find shortest paths along transportation network.</p>
<p>To be able to conduct network analysis, it is, of course, necessary to have a network that is used for the analyses. <a class="reference external" href="https://github.com/gboeing/osmnx">OSMnx</a> package that we just explored in previous tutorial, makes it really easy to retrieve routable networks from OpenStreetMap with different transport modes (walking, cycling and driving). OSMnx also combines some functionalities from <code class="docutils literal notranslate"><span class="pre">networkx</span></code> module to make it straightforward to conduct routing along OpenStreetMap data.</p>
<p>Next we will test the routing functionalities of OSMnx by finding a shortest path between two points based on drivable roads. With tiny modifications, it is also possible to repeat the analysis for the walkable street network.</p>
<section id="get-the-network">
<h2>Get the network<a class="headerlink" href="#get-the-network" title="Permalink to this heading">#</a></h2>
<p>Let’s again start by importing the required modules</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">osmnx</span> <span class="k">as</span> <span class="nn">ox</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">geopandas</span> <span class="k">as</span> <span class="nn">gpd</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">pyproj</span> <span class="kn">import</span> <span class="n">CRS</span>
</pre></div>
</div>
<p>When fetching netowrk data from OpenStreetMap using OSMnx, it is possible to define the type of street network using the <code class="docutils literal notranslate"><span class="pre">network_type</span></code> parameter (options: <code class="docutils literal notranslate"><span class="pre">drive</span></code>, <code class="docutils literal notranslate"><span class="pre">walk</span></code> and <code class="docutils literal notranslate"><span class="pre">bike</span></code>).
Let’s download the OSM data from Kamppi but this only the drivable network. Alternatively, you can also fetch the walkable network (this will take a bit longer time).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">place_name</span> <span class="o">=</span> <span class="s2">&quot;Kamppi, Helsinki, Finland&quot;</span>
<span class="n">graph</span> <span class="o">=</span> <span class="n">ox</span><span class="o">.</span><span class="n">graph_from_place</span><span class="p">(</span><span class="n">place_name</span><span class="p">,</span> <span class="n">network_type</span><span class="o">=</span><span class="s2">&quot;drive&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Plot the graph:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">ox</span><span class="o">.</span><span class="n">plot_graph</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
</pre></div>
</div>
<p>Okey so now we have retrieved only such streets where it is possible to drive with a car. Let’s confirm
this by taking a look at the attributes of the street network. Easiest way to do this is to convert the
graph (nodes and edges) into GeoDataFrames.</p>
<p>Converting graph into a GeoDataFrame can be done with function <code class="docutils literal notranslate"><span class="pre">graph_to_gdfs()</span></code> that we already used in previous tutorial. With parameters <code class="docutils literal notranslate"><span class="pre">nodes</span></code> and <code class="docutils literal notranslate"><span class="pre">edges</span></code>, it is possible to control whether to retrieve both nodes and edges from the graph.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Retrieve only edges from the graph</span>
<span class="n">edges</span> <span class="o">=</span> <span class="n">ox</span><span class="o">.</span><span class="n">graph_to_gdfs</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">edges</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Check columns</span>
<span class="n">edges</span><span class="o">.</span><span class="n">columns</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Check crs</span>
<span class="n">edges</span><span class="o">.</span><span class="n">crs</span>
</pre></div>
</div>
<p>Note that the CRS of the GeoDataFrame is be WGS84 (epsg: 4326).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">edges</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
<!-- #region -->
<p>Okey, so we have quite many columns in our GeoDataFrame. Most of the columns are fairly self-explanatory but the following table describes all of them.
Most of the attributes come directly from the OpenStreetMap, however, columns <code class="docutils literal notranslate"><span class="pre">u</span></code> and <code class="docutils literal notranslate"><span class="pre">v</span></code> are Networkx specific ids. You can click on the links to get more information about each attribute:</p>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Column</p></th>
<th class="head"><p>Description</p></th>
<th class="head"><p>Data type</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference external" href="http://wiki.openstreetmap.org/wiki/Key:bridge">bridge</a></p></td>
<td><p>Bridge feature</p></td>
<td><p>boolean</p></td>
</tr>
<tr class="row-odd"><td><p>geometry</p></td>
<td><p>Geometry of the feature</p></td>
<td><p>Shapely.geometry</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="http://wiki.openstreetmap.org/wiki/Key:highway">highway</a></p></td>
<td><p>Tag for roads (road type)</p></td>
<td><p>str / list</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="http://wiki.openstreetmap.org/wiki/Key:lanes">lanes</a></p></td>
<td><p>Number of lanes</p></td>
<td><p>int (or nan)</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="http://wiki.openstreetmap.org/wiki/Key:length">lenght</a></p></td>
<td><p>Length of feature (meters)</p></td>
<td><p>float</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="http://wiki.openstreetmap.org/wiki/Key:maxspeed">maxspeed</a></p></td>
<td><p>maximum legal speed limit</p></td>
<td><p>int /list</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="http://wiki.openstreetmap.org/wiki/Key:name">name</a></p></td>
<td><p>Name of the (street) element</p></td>
<td><p>str (or nan)</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="http://wiki.openstreetmap.org/wiki/Key:oneway">oneway</a></p></td>
<td><p>One way road</p></td>
<td><p>boolean</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="http://wiki.openstreetmap.org/wiki/Node">osmid</a></p></td>
<td><p>Unique ids for the element</p></td>
<td><p>list</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="http://ow.ly/bV8n30h7Ufm">u</a></p></td>
<td><p>The first node of edge</p></td>
<td><p>int</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="http://ow.ly/bV8n30h7Ufm">v</a></p></td>
<td><p>The last node of edge</p></td>
<td><p>int</p></td>
</tr>
</tbody>
</table>
<!-- #endregion -->
<p>Let’s take a look what kind of features we have in the <code class="docutils literal notranslate"><span class="pre">highway</span></code> column:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">edges</span><span class="p">[</span><span class="s2">&quot;highway&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()</span>
</pre></div>
</div>
<p>Okey, now we can confirm that as a result our street network indeed only contains such streets where it is allowed to drive with a car as there are no e.g. cycleways or footways included in the data.</p>
<p>As the data is in WGS84 format, we might want to reproject our data into a metric system before proceeding to the shortest path analysis.
We can re-project the graph from latitudes and longitudes to an appropriate UTM zone using the <a class="reference external" href="https://osmnx.readthedocs.io/en/stable/osmnx.html#osmnx.projection.project_graph">project_graph()</a> function from OSMnx.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Project the data</span>
<span class="n">graph_proj</span> <span class="o">=</span> <span class="n">ox</span><span class="o">.</span><span class="n">project_graph</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Get Edges and Nodes</span>
<span class="n">nodes_proj</span><span class="p">,</span> <span class="n">edges_proj</span> <span class="o">=</span> <span class="n">ox</span><span class="o">.</span><span class="n">graph_to_gdfs</span><span class="p">(</span><span class="n">graph_proj</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">edges</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Coordinate system:&quot;</span><span class="p">,</span> <span class="n">edges_proj</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">edges_proj</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
<p>Okey, as we can see from the CRS the data is now in <a class="reference external" href="https://en.wikipedia.org/wiki/Universal_Transverse_Mercator_coordinate_system">UTM projection</a> using zone 35 which is the one used for Finland, and indeed the orientation of the map and the geometry values also confirm this.</p>
<p>Furthermore, we can check the epsg code of this projection using pyproj CRS:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">CRS</span><span class="p">(</span><span class="n">edges_proj</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span><span class="o">.</span><span class="n">to_epsg</span><span class="p">()</span>
</pre></div>
</div>
<p>Indeed, the projection is now <a class="reference external" href="https://epsg.io/32635">WGS 84 / UTM zone 35N, EPSG:32635</a>.</p>
</section>
<section id="analyzing-the-network-properties">
<h2>Analyzing the network properties<a class="headerlink" href="#analyzing-the-network-properties" title="Permalink to this heading">#</a></h2>
<p>Now as we have seen some of the basic functionalities of OSMnx such as downloading the data and converting data from graph to GeoDataFrame, we can take a look some of the analytical features of omsnx. Osmnx includes many useful functionalities to extract information about the network.</p>
<p>To calculate some of the basic street network measures we can use <a class="reference external" href="https://osmnx.readthedocs.io/en/stable/osmnx.html#osmnx.stats.basic_stats">basic_stats()</a> function in OSMnx:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Calculate network statistics</span>
<span class="n">stats</span> <span class="o">=</span> <span class="n">ox</span><span class="o">.</span><span class="n">basic_stats</span><span class="p">(</span><span class="n">graph_proj</span><span class="p">,</span> <span class="n">circuity_dist</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span><span class="p">)</span>
<span class="n">stats</span>
</pre></div>
</div>
<p>To be able to extract the more advanced statistics (and some of the missing ones above) from the street network, it is required to have information about the coverage area of the network. Let’s calculate the area of the <a class="reference external" href="https://en.wikipedia.org/wiki/Convex_hull">convex hull</a> of the street network and see what we can get.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Get the Convex Hull of the network</span>
<span class="n">convex_hull</span> <span class="o">=</span> <span class="n">edges_proj</span><span class="o">.</span><span class="n">unary_union</span><span class="o">.</span><span class="n">convex_hull</span>

<span class="c1"># Show output</span>
<span class="n">convex_hull</span>
</pre></div>
</div>
<p>Now we can use the Convex Hull above to calculate <a class="reference external" href="https://osmnx.readthedocs.io/en/stable/osmnx.html#osmnx.stats.extended_stats">extended statistics for the network</a>. As some of the metrics are produced separately for each node, they produce a lot of output. Here, we combine the basic and extended statistics into one pandas Series to keep things in more compact form.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Calculate the area</span>
<span class="n">area</span> <span class="o">=</span> <span class="n">convex_hull</span><span class="o">.</span><span class="n">area</span>

<span class="c1"># Calculate statistics with density information</span>
<span class="n">stats</span> <span class="o">=</span> <span class="n">ox</span><span class="o">.</span><span class="n">basic_stats</span><span class="p">(</span><span class="n">graph_proj</span><span class="p">,</span> <span class="n">area</span><span class="o">=</span><span class="n">area</span><span class="p">)</span>
<span class="n">extended_stats</span> <span class="o">=</span> <span class="n">ox</span><span class="o">.</span><span class="n">extended_stats</span><span class="p">(</span><span class="n">graph_proj</span><span class="p">,</span> <span class="n">ecc</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cc</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># Add extened statistics to the basic statistics</span>
<span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">extended_stats</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="n">stats</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

<span class="c1"># Convert the dictionary to a Pandas series for a nicer output</span>
<span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">stats</span><span class="p">)</span>
</pre></div>
</div>
<p>As we can see, now we have a <strong>LOT</strong> of information about our street network that can be used to understand its structure. We can for example see that the average node density in our network is <code class="docutils literal notranslate"><span class="pre">149</span> <span class="pre">nodes/km</span></code> and that the total edge length of our network is almost 20 kilometers.</p>
<p>Furthermore, we can see that the <a class="reference external" href="https://en.wikipedia.org/wiki/Centrality">degree centrality</a> of our network is on average <code class="docutils literal notranslate"><span class="pre">0.0326515</span></code>. Degree is a simple centrality measure that counts how many neighbors a node has (here a fraction of nodes it is connected to). Another interesting measure is the <a class="reference external" href="https://en.wikipedia.org/wiki/PageRank">PageRank</a> that measures the importance of specific node in the graph. Here we can see that the most important node in our graph seem to a node with osmid <code class="docutils literal notranslate"><span class="pre">25416262</span></code>. PageRank was the algorithm that Google first developed (Larry Page &amp; Sergei Brin) to order the search engine results and became famous for.</p>
<p>You can read the <a class="reference external" href="https://en.wikipedia.org/wiki/Centrality">Wikipedia article about different centrality measures</a> if you are interested what the other centrality measures mean.</p>
</section>
<section id="shortest-path-analysis">
<h2>Shortest path analysis<a class="headerlink" href="#shortest-path-analysis" title="Permalink to this heading">#</a></h2>
<p>Let’s now calculate the shortest path between two points using the <a class="reference external" href="https://networkx.github.io/documentation/networkx-1.10/reference/generated/networkx.algorithms.shortest_paths.generic.shortest_path.html#shortest-path">shortest path function in Networkx</a>.</p>
<section id="origin-and-destination-points">
<h3>Origin and destination points<a class="headerlink" href="#origin-and-destination-points" title="Permalink to this heading">#</a></h3>
<p>First we need to specify the source and target locations for our route. If you are familiar with the Kamppi area, you can specify a custom placename as a source location. Or, you can choose from these options:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://nominatim.openstreetmap.org/ui/search.html?q=Maria+01">Maria 01</a> and old hospital area and current startup hub</p></li>
<li><p><a class="reference external" href="https://nominatim.openstreetmap.org/ui/search.html?q=tennispalatsi">Tennispalatsi</a> - a big movie theatre (<em>note! Routing in the drivable network will fail with this input</em>).</p></li>
</ul>
<p>We could figure out the coordinates for these locations manually, and create shapely points based on the coordinates.
However,  it is more handy to fetch the location of our source destination directly from OSM:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set place name</span>
<span class="n">place</span> <span class="o">=</span> <span class="s2">&quot;Maria 01, Helsinki&quot;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Geocode the place name</span>
<span class="n">geocoded_place</span> <span class="o">=</span> <span class="n">ox</span><span class="o">.</span><span class="n">geocode_to_gdf</span><span class="p">(</span><span class="n">place</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Check the result</span>
<span class="n">geocoded_place</span>
</pre></div>
</div>
<p>As output, we received the building footprint. From here, we can get the centroid as the source location of our shortest path analysis. However, we first need to project the data into the correct crs:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Re-project</span>
<span class="n">geocoded_place</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">CRS</span><span class="p">(</span><span class="n">edges_proj</span><span class="o">.</span><span class="n">crs</span><span class="p">),</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Get centroid as shapely point</span>
<span class="n">origin</span> <span class="o">=</span> <span class="n">geocoded_place</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">origin</span><span class="p">)</span>
</pre></div>
</div>
<p>Great! Now we have defined the origin point of our analysis somewhere in the area of interest.</p>
<p>Next, we still need the destination location. To make things simple, we can set the easternmost node in our road network as the destination. Let’s have another look at our node data:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">nodes_proj</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
<p>We can find the easternmost nodes based on the x coordinates:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Retrieve the maximum x value (i.e. the most eastern)</span>
<span class="n">maxx</span> <span class="o">=</span> <span class="n">nodes_proj</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
</pre></div>
</div>
<p>Let’s find out the coresponding point geometries for these noodes.</p>
<p>We can do this by using the <code class="docutils literal notranslate"><span class="pre">.loc</span></code> function of Pandas that we have used already many times in earlier tutorials.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Easternmost point</span>
<span class="n">destination</span> <span class="o">=</span> <span class="n">nodes_proj</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">nodes_proj</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">maxx</span><span class="p">,</span> <span class="s2">&quot;geometry&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">destination</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="nearest-node">
<h3>Nearest node<a class="headerlink" href="#nearest-node" title="Permalink to this heading">#</a></h3>
<p>Let’s now find the nearest graph nodes (and their node IDs) to these points using OSMnx <a class="reference external" href="https://osmnx.readthedocs.io/en/stable/osmnx.html#osmnx.utils.get_nearest_node">get_nearest_node</a>.
As a starting point, we have the two Shapely Point objects we just defined as the origin and destination locations.</p>
<p>According to the documentation of this function, we need to parse Point coordinates as coordinate-tuples in this order: <code class="docutils literal notranslate"><span class="pre">latitude,</span> <span class="pre">longitude</span></code>(or <code class="docutils literal notranslate"><span class="pre">y,</span> <span class="pre">x</span></code>). As our data is now projected to UTM projection, we need to specify with <code class="docutils literal notranslate"><span class="pre">method</span></code> parameter that the function uses <code class="docutils literal notranslate"><span class="pre">'euclidean'</span></code> distances to calculate the distance from the point to the closest node (with decimal derees, use <code class="docutils literal notranslate"><span class="pre">'haversine'</span></code>, which determines the great-circle distances). The method parameter is important if you want to know the actual distance between the Point and the closest node which you can retrieve by specifying parameter <code class="docutils literal notranslate"><span class="pre">return_dist=True</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Get origin x and y coordinates</span>
<span class="n">orig_xy</span> <span class="o">=</span> <span class="p">(</span><span class="n">origin</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">origin</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>

<span class="c1"># Get target x and y coordinates</span>
<span class="n">target_xy</span> <span class="o">=</span> <span class="p">(</span><span class="n">destination</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">destination</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Find the node in the graph that is closest to the origin point (here, we want to get the node id)</span>
<span class="n">orig_node_id</span> <span class="o">=</span> <span class="n">ox</span><span class="o">.</span><span class="n">get_nearest_node</span><span class="p">(</span><span class="n">graph_proj</span><span class="p">,</span> <span class="n">orig_xy</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span><span class="p">)</span>
<span class="n">orig_node_id</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Find the node in the graph that is closest to the target point (here, we want to get the node id)</span>
<span class="n">target_node_id</span> <span class="o">=</span> <span class="n">ox</span><span class="o">.</span><span class="n">get_nearest_node</span><span class="p">(</span><span class="n">graph_proj</span><span class="p">,</span> <span class="n">target_xy</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span><span class="p">)</span>
<span class="n">target_node_id</span>
</pre></div>
</div>
<p>Now we have the IDs for the closest nodes that were found from the graph to the origin and target points that we specified.</p>
<p>Let’s retrieve the node information from the <code class="docutils literal notranslate"><span class="pre">nodes_proj</span></code> GeoDataFrame by passing the ids to the <code class="docutils literal notranslate"><span class="pre">loc</span></code> indexer</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Retrieve the rows from the nodes GeoDataFrame based on the node id (node id is the index label)</span>
<span class="n">orig_node</span> <span class="o">=</span> <span class="n">nodes_proj</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">orig_node_id</span><span class="p">]</span>
<span class="n">target_node</span> <span class="o">=</span> <span class="n">nodes_proj</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">target_node_id</span><span class="p">]</span>
</pre></div>
</div>
<p>Let’s also create a GeoDataFrame that contains these points</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create a GeoDataFrame from the origin and target points</span>
<span class="n">od_nodes</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span>
    <span class="p">[</span><span class="n">orig_node</span><span class="p">,</span> <span class="n">target_node</span><span class="p">],</span> <span class="n">geometry</span><span class="o">=</span><span class="s2">&quot;geometry&quot;</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="n">nodes_proj</span><span class="o">.</span><span class="n">crs</span>
<span class="p">)</span>
<span class="n">od_nodes</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
<p>Okay, as a result we got now the closest node IDs of our origin and target locations. As you can see, the <code class="docutils literal notranslate"><span class="pre">index</span></code> in this GeoDataFrame corresponds to the IDs that we found with <code class="docutils literal notranslate"><span class="pre">get_nearest_node()</span></code> function.</p>
</section>
<section id="routing">
<h3>Routing<a class="headerlink" href="#routing" title="Permalink to this heading">#</a></h3>
<p>Now we are ready to do the routing and find the shortest path between the origin and target locations
by using the <code class="docutils literal notranslate"><span class="pre">shortest_path()</span></code> <a class="reference external" href="https://networkx.github.io/documentation/networkx-1.10/reference/generated/networkx.algorithms.shortest_paths.generic.shortest_path.html">function</a> of networkx.
With <code class="docutils literal notranslate"><span class="pre">weight</span></code> -parameter we can specify that <code class="docutils literal notranslate"><span class="pre">'length'</span></code> attribute should be used as the cost impedance in the routing. If specifying the weight parameter, NetworkX will use by default Dijkstra’s algorithm to find the optimal route. We need to specify the graph that is used for routing, and the origin <code class="docutils literal notranslate"><span class="pre">ID</span></code> (<em>source</em>) and the target <code class="docutils literal notranslate"><span class="pre">ID</span></code> in between the shortest path will be calculated:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Calculate the shortest path</span>
<span class="n">route</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span>
    <span class="n">G</span><span class="o">=</span><span class="n">graph_proj</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="n">orig_node_id</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="n">target_node_id</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="s2">&quot;length&quot;</span>
<span class="p">)</span>

<span class="c1"># Show what we have</span>
<span class="nb">print</span><span class="p">(</span><span class="n">route</span><span class="p">)</span>
</pre></div>
</div>
<p>As a result we get a list of all the nodes that are along the shortest path.</p>
<ul class="simple">
<li><p>We could extract the locations of those nodes from the <code class="docutils literal notranslate"><span class="pre">nodes_proj</span></code> GeoDataFrame and create a LineString presentation of the points, but luckily, OSMnx can do that for us and we can plot shortest path by using <code class="docutils literal notranslate"><span class="pre">plot_graph_route()</span></code> function:</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Plot the shortest path</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">ox</span><span class="o">.</span><span class="n">plot_graph_route</span><span class="p">(</span><span class="n">graph_proj</span><span class="p">,</span> <span class="n">route</span><span class="p">)</span>
</pre></div>
</div>
<p>Nice! Now we have the shortest path between our origin and target locations.
Being able to analyze shortest paths between locations can be valuable information for many applications.
Here, we only analyzed the shortest paths based on distance but quite often it is more useful to find the
optimal routes between locations based on the travelled time. Here, for example we could calculate the time that it takes to cross each road segment by dividing the length of the road segment with the speed limit and calculate the optimal routes by taking into account the speed limits as well that might alter the result especially on longer trips than here.</p>
</section>
</section>
<section id="saving-shortest-paths-to-disk">
<h2>Saving shortest paths to disk<a class="headerlink" href="#saving-shortest-paths-to-disk" title="Permalink to this heading">#</a></h2>
<p>Quite often you need to save the route e.g. as a Shapefile.
Hence, let’s continue still a bit and see how we can make a Shapefile of our route with some information associated with it.</p>
<ul class="simple">
<li><p>First we need to get the nodes that belong to the shortest path:</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Get the nodes along the shortest path</span>
<span class="n">route_nodes</span> <span class="o">=</span> <span class="n">nodes_proj</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">route</span><span class="p">]</span>
<span class="n">route_nodes</span>
</pre></div>
</div>
<p>As we can see, now we have all the nodes that were part of the shortest path as a GeoDataFrame.</p>
<ul class="simple">
<li><p>Now we can create a LineString out of the Point geometries of the nodes:</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">shapely.geometry</span> <span class="kn">import</span> <span class="n">LineString</span><span class="p">,</span> <span class="n">Point</span>

<span class="c1"># Create a geometry for the shortest path</span>
<span class="n">route_line</span> <span class="o">=</span> <span class="n">LineString</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">route_nodes</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">values</span><span class="p">))</span>
<span class="n">route_line</span>
</pre></div>
</div>
<p>Now we have the route as a LineString geometry.</p>
<ul class="simple">
<li><p>Let’s make a GeoDataFrame out of it having some useful information about our route such as a list of the osmids that are part of the route and the length of the route.</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create a GeoDataFrame</span>
<span class="n">route_geom</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span>
    <span class="p">[[</span><span class="n">route_line</span><span class="p">]],</span> <span class="n">geometry</span><span class="o">=</span><span class="s2">&quot;geometry&quot;</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="n">edges_proj</span><span class="o">.</span><span class="n">crs</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]</span>
<span class="p">)</span>

<span class="c1"># Add a list of osmids associated with the route</span>
<span class="n">route_geom</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;osmids&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">route_nodes</span><span class="p">[</span><span class="s2">&quot;osmid&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">))</span>

<span class="c1"># Calculate the route length</span>
<span class="n">route_geom</span><span class="p">[</span><span class="s2">&quot;length_m&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">route_geom</span><span class="o">.</span><span class="n">length</span>

<span class="n">route_geom</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
<p>Now we have a GeoDataFrame that we can save to disk. Let’s still confirm that everything is ok by plotting our route on top of our street network and some buildings, and plot also the origin and target points on top of our map.</p>
<ul class="simple">
<li><p>Get buildings:</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">tags</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;building&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
<span class="n">buildings</span> <span class="o">=</span> <span class="n">ox</span><span class="o">.</span><span class="n">geometries_from_place</span><span class="p">(</span><span class="n">place_name</span><span class="p">,</span> <span class="n">tags</span><span class="p">)</span>
</pre></div>
</div>
<p>re-project buildings</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">buildings_proj</span> <span class="o">=</span> <span class="n">buildings</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">CRS</span><span class="p">(</span><span class="n">edges_proj</span><span class="o">.</span><span class="n">crs</span><span class="p">))</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Let’s now plot the route and the street network elements to verify that everything is as it should:</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Plot edges and nodes</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">edges_proj</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">linewidth</span><span class="o">=</span><span class="mf">0.75</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;gray&quot;</span><span class="p">)</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">nodes_proj</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;gray&quot;</span><span class="p">)</span>

<span class="c1"># Add buildings</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">buildings_proj</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">facecolor</span><span class="o">=</span><span class="s2">&quot;khaki&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>

<span class="c1"># Add the route</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">route_geom</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;--&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">)</span>

<span class="c1"># Add the origin and destination nodes of the route</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">od_nodes</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">24</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;green&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Great everything seems to be in order! As you can see, now we have a full control of all the elements of our map and we can use all the aesthetic properties that matplotlib provides to modify how our map will look like. Now we are almost ready to save our data into disk.</p>
<ul class="simple">
<li><p>As there are certain columns with such data values that Shapefile format does not support (such as <code class="docutils literal notranslate"><span class="pre">list</span></code> or <code class="docutils literal notranslate"><span class="pre">boolean</span></code>), we need to convert those into strings to be able to export the data to Shapefile:</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Columns with invalid values</span>
<span class="n">invalid_cols</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;lanes&quot;</span><span class="p">,</span> <span class="s2">&quot;maxspeed&quot;</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="s2">&quot;oneway&quot;</span><span class="p">,</span> <span class="s2">&quot;osmid&quot;</span><span class="p">]</span>

<span class="c1"># Iterate over invalid columns and convert them to string format</span>
<span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">invalid_cols</span><span class="p">:</span>
    <span class="n">edges_proj</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">edges_proj</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">edges_proj</span><span class="o">.</span><span class="n">dtypes</span><span class="p">)</span>
</pre></div>
</div>
<p>Now we can see that most of the attributes are of type <code class="docutils literal notranslate"><span class="pre">object</span></code> that quite often (such as ours here) refers to a string type of data.</p>
<ul class="simple">
<li><p>Now we are finally ready to parse the output filepaths and save the data into disk:</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os</span>

<span class="c1"># Parse the place name for the output file names (replace spaces with underscores and remove commas)</span>
<span class="n">place_name_out</span> <span class="o">=</span> <span class="n">place_name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot;_&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>

<span class="c1"># Output directory</span>
<span class="n">out_dir</span> <span class="o">=</span> <span class="s2">&quot;data&quot;</span>

<span class="c1"># Parse output file paths</span>
<span class="n">streets_out</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">out_dir</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">_streets.shp&quot;</span> <span class="o">%</span> <span class="n">place_name_out</span><span class="p">)</span>
<span class="n">route_out</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">out_dir</span><span class="p">,</span> <span class="s2">&quot;Route_from_a_to_b_at_</span><span class="si">%s</span><span class="s2">.shp&quot;</span> <span class="o">%</span> <span class="n">place_name_out</span><span class="p">)</span>
<span class="n">nodes_out</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">out_dir</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">_nodes.shp&quot;</span> <span class="o">%</span> <span class="n">place_name_out</span><span class="p">)</span>
<span class="n">buildings_out</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">out_dir</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">_buildings.shp&quot;</span> <span class="o">%</span> <span class="n">place_name_out</span><span class="p">)</span>
<span class="n">od_out</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">out_dir</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">_route_OD_points.shp&quot;</span> <span class="o">%</span> <span class="n">place_name_out</span><span class="p">)</span>

<span class="c1"># Save files</span>
<span class="n">edges_proj</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="n">streets_out</span><span class="p">)</span>
<span class="n">route_geom</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="n">route_out</span><span class="p">)</span>
<span class="n">nodes_proj</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="n">nodes_out</span><span class="p">)</span>
<span class="n">od_nodes</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="n">od_out</span><span class="p">)</span>
<span class="n">buildings</span><span class="p">[[</span><span class="s2">&quot;geometry&quot;</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="s2">&quot;addr:street&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="n">buildings_out</span><span class="p">)</span>
</pre></div>
</div>
<p>Great, now we have saved all the data that was used to produce the maps as Shapefiles.</p>
</section>
</section>


                </article>
              

              
              
              
              
                <footer class="prev-next-footer">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#get-the-network">Get the network</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#analyzing-the-network-properties">Analyzing the network properties</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#shortest-path-analysis">Shortest path analysis</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#origin-and-destination-points">Origin and destination points</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#nearest-node">Nearest node</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#routing">Routing</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#saving-shortest-paths-to-disk">Saving shortest paths to disk</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Henrikki Tenkanen, Vuokko Heikinheimo, David Whipp
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2020-2022, Henrikki Tenkanen, Vuokko Heikinheimo, David Whipp.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../../_static/scripts/bootstrap.js?digest=8d27b9dea8ad943066ae"></script>
<script src="../../../_static/scripts/pydata-sphinx-theme.js?digest=8d27b9dea8ad943066ae"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>