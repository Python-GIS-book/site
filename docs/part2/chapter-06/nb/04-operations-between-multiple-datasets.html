
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Operations between multiple datasets</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" href="../../../_static/styles/sphinx-book-theme.css?digest=62ba249389abaaa9ffc34bf36a076bdc1d65ee18" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/css/pythongis.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/css/custom-toggle-button.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script>let toggleHintShow = 'Show the solution';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../../_static/togglebutton.js"></script>
    <script src="../../../_static/scripts/sphinx-book-theme.js?digest=f31d14ad54b65d19161ba51d4ffff3a77ae00456"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="Raster data processing" href="../../chapter-07/index.html" />
    <link rel="prev" title="Geometric data manipulations" href="03-geometric-manipulation.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../../../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../../../_static/pythongis-logo.png" class="logo" alt="logo">
      
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Part I - Python essentials
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../../part1/chapter-01/index.html">
   Getting started
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../part1/chapter-01/nb/00-motivation.html">
     Motivation
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../part1/chapter-01/nb/01-computers-and-programs.html">
     Computers and programs
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../part1/chapter-01/nb/02-why-python.html">
     Why Python?
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../part1/chapter-01/nb/03-writing-and-running-python-code.html">
     Writing and running Python code
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../part1/chapter-01/nb/04-using-jupyterlab.html">
     Using JupyterLab for writing code
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../part1/chapter-01/nb/05-installation.html">
     Installing Python and adding libraries
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../../part1/chapter-02/index.html">
   Basic programming concepts
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/>
  <label for="toctree-checkbox-2">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../part1/chapter-02/nb/00-python-basics.html">
     Basic elements of Python
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../part1/chapter-02/nb/01-for-loops.html">
     for loops
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../part1/chapter-02/nb/02-conditional-statements.html">
     Conditional statements
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../part1/chapter-02/nb/03-functions.html">
     Functions
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../part1/chapter-02/nb/04-writing-scripts.html">
     Writing script files
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../part1/chapter-02/nb/05-modules.html">
     Loading and using modules
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../part1/chapter-02/nb/06-exercises.html">
     Exercises
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../../part1/chapter-03/index.html">
   Introduction to data analysis with Python
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/>
  <label for="toctree-checkbox-3">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../part1/chapter-03/nb/00-pandas-basics.html">
     Getting started with data analysis
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../part1/chapter-03/nb/01-data-manipulation.html">
     Common tabular operations in pandas
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../part1/chapter-03/nb/02-data-analysis.html">
     Data wrangling, grouping and aggregation
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../part1/chapter-03/nb/03-temporal-data.html">
     Working with temporal data
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../part1/chapter-03/nb/04-exercises.html">
     Exercises
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../../part1/chapter-04/index.html">
   Introduction to data visualization
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/>
  <label for="toctree-checkbox-4">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../part1/chapter-04/nb/00-plotting-in-python.html">
     Plotting in Python
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../part1/chapter-04/nb/01-basic-plotting.html">
     Plotting with pandas and matplotlib
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../part1/chapter-04/nb/02-subplots.html">
     Creating subplots
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../part1/chapter-04/nb/03-plot-formatting.html">
     Effective plot design: line plots
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../part1/chapter-04/nb/04-exercises.html">
     Exercises
    </a>
   </li>
  </ul>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Part II - Introduction to GIS with Python
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../chapter-05/index.html">
   Getting started
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/>
  <label for="toctree-checkbox-5">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../chapter-05/nb/00-motivation-to-use-python-for-gis.html">
     Motivation
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../chapter-05/nb/01-introduction-to-geographic-data-in-python.html">
     Introduction to geographic data in Python
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 current active has-children">
  <a class="reference internal" href="../index.html">
   Vector data processing
  </a>
  <input checked="" class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" type="checkbox"/>
  <label for="toctree-checkbox-6">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul class="current">
   <li class="toctree-l2">
    <a class="reference internal" href="00-introduction-to-geopandas.html">
     Introduction to spatial data analysis with geopandas
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="01-data-io.html">
     Data in/out: Preparing GeoDataFrames from spatial data
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="02-coordinate-reference-system.html">
     Coordinate Reference Systems
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="03-geometric-manipulation.html">
     Geometric data manipulations
    </a>
   </li>
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     Operations between multiple datasets
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../chapter-07/index.html">
   Raster data processing
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" type="checkbox"/>
  <label for="toctree-checkbox-7">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../chapter-07/nb/01-reading-raster.html">
     Reading raster files
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../chapter-07/nb/plotting-raster.html">
     Visualizing raster layers
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../chapter-07/nb/clipping-raster.html">
     Masking / clipping raster
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../chapter-07/nb/raster-map-algebra.html">
     Raster map algebra
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../chapter-07/nb/raster-mosaic.html">
     Creating a raster mosaic
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../chapter-07/nb/zonal-statistics.html">
     Zonal statistics
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../chapter-07/nb/read-cogs.html">
     Read Cloud Optimized Geotiffs
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../chapter-08/index.html">
   Geographic data visualization
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" type="checkbox"/>
  <label for="toctree-checkbox-8">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../chapter-08/nb/00-introduction-to-geographic-visualization.html">
     Introduction to geographic visualization
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../chapter-08/nb/01-static-maps.html">
     Static maps
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../chapter-08/nb/02-interactive-maps.html">
     Interactive maps
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../chapter-08/nb/03-map-design-principles-and-colors.html">
     Designing maps
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../chapter-09/index.html">
   Using online geographic data sources
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-9" name="toctree-checkbox-9" type="checkbox"/>
  <label for="toctree-checkbox-9">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../chapter-09/nb/00-retrieve_osm_data.html">
     Retrieving OpenStreetMap data
    </a>
   </li>
  </ul>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Part III - Case studies
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../../part3/index.html">
   Geographic data analysis applications
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Back matter
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../../back-matter/nb/acknowledgements.html">
   Acknowledgements
  </a>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../../back-matter/appendices.html">
   Appendices
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-10" name="toctree-checkbox-10" type="checkbox"/>
  <label for="toctree-checkbox-10">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../back-matter/nb/appendix-1.html">
     Version control with git
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../back-matter/nb/appendix-2.html">
     Collaborative coding with GitHub
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../back-matter/nb/appendix-3.html">
     Using Python script files
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../back-matter/nb/appendix-4.html">
     Testing and debugging your code
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../back-matter/nb/appendix-5.html">
     Solutions to questions
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../back-matter/nb/appendix-6.html">
     Exercise solutions
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../back-matter/nb/glossary.html">
   Glossary
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../back-matter/nb/references.html">
   References
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../authors.html">
   About the authors
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Datasets
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../../data/index.html">
   Overview
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../data/noaa-data.html">
   NOAA Weather data
  </a>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Theme by the <a href="https://ebp.jupyterbook.org">Executable Book Project</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<div class="menu-dropdown menu-dropdown-launch-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Launch interactive content">
      <i class="fas fa-rocket"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://mybinder.org/v2/gh/Python-GIS-book/site/master?urlpath=lab/tree/part2/chapter-06/nb/04-operations-between-multiple-datasets.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Launch on Binder"
>
  

<span class="headerbtn__icon-container">
  
    <img src="../../../_static/images/logo_binder.svg">
  </span>
<span class="headerbtn__text-container">Binder</span>
</a>

      </li>
      
    </ul>
  </div>
</div>

<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>
<a href="https://github.com/Python-GIS-book/site/edit/master/part2/chapter-06/nb/04-operations-between-multiple-datasets.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="bottom"
title="Edit this page"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-pencil-alt"></i>
  </span>

</a>

<div class="menu-dropdown menu-dropdown-download-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Download this page">
      <i class="fas fa-download"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="../../../_sources/part2/chapter-06/nb/04-operations-between-multiple-datasets.ipynb.txt"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Download source file"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="headerbtn__text-container">.ipynb</span>
</a>

      </li>
      
      <li>
        
<button onclick="printPdf(this)"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="left"
title="Print to PDF"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="headerbtn__text-container">.pdf</span>
</button>

      </li>
      
    </ul>
  </div>
</div>
<label for="__page-toc"
  class="headerbtn headerbtn-page-toc"
  
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-list"></i>
  </span>

</label>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
    <div class="tocsection onthispage pt-5 pb-3">
        <i class="fas fa-list"></i> Contents
    </div>
    <nav id="bd-toc-nav" aria-label="Page">
        <ul class="visible nav section-nav flex-column">
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#">
   Operations between multiple datasets
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#selecting-data-based-on-spatial-relationships">
     Selecting data based on spatial relationships
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#how-to-check-if-point-is-inside-a-polygon">
       How to check if point is inside a polygon?
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#intersect">
     Intersect
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#point-in-polygon-using-geopandas">
     Point in Polygon using Geopandas
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#reading-kml-files-in-geopandas">
       Reading KML-files in Geopandas
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#overlay-analysis">
     Overlay analysis
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#spatial-join">
   Spatial join
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#join-the-layers">
     Join the layers
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#spatial-join-nearest">
     Spatial join nearest
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#nearest-neighbour-analysis">
   Nearest Neighbour Analysis
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#nearest-point-using-shapely">
     Nearest point using Shapely
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#nearest-points-using-geopandas">
     Nearest points using Geopandas
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#nearest-neighbor-analysis-with-large-datasets">
   Nearest neighbor analysis with large datasets
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#motivation">
     Motivation
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#efficient-nearest-neighbor-search-with-geopandas-and-scikit-learn">
     Efficient nearest neighbor search with Geopandas and scikit-learn
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#what-did-we-just-do-explanation">
       What did we just do? Explanation.
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#combining-the-neighboring-datasets">
       Combining the neighboring datasets
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#are-the-results-correct-validation">
       Are the results correct? Validation
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#spatial-index-how-to-boost-spatial-queries">
     Spatial index - How to boost spatial queries?
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#id1">
       Motivation
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#spatial-index-with-geopandas">
     Spatial index with Geopandas
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#putting-pieces-together-performance-comparisons">
       Putting pieces together - Performance comparisons
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#counting-the-intersections">
       Counting the intersections
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#note">
       Note
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>

    </nav>
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>Operations between multiple datasets</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#">
   Operations between multiple datasets
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#selecting-data-based-on-spatial-relationships">
     Selecting data based on spatial relationships
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#how-to-check-if-point-is-inside-a-polygon">
       How to check if point is inside a polygon?
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#intersect">
     Intersect
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#point-in-polygon-using-geopandas">
     Point in Polygon using Geopandas
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#reading-kml-files-in-geopandas">
       Reading KML-files in Geopandas
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#overlay-analysis">
     Overlay analysis
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#spatial-join">
   Spatial join
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#join-the-layers">
     Join the layers
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#spatial-join-nearest">
     Spatial join nearest
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#nearest-neighbour-analysis">
   Nearest Neighbour Analysis
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#nearest-point-using-shapely">
     Nearest point using Shapely
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#nearest-points-using-geopandas">
     Nearest points using Geopandas
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#nearest-neighbor-analysis-with-large-datasets">
   Nearest neighbor analysis with large datasets
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#motivation">
     Motivation
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#efficient-nearest-neighbor-search-with-geopandas-and-scikit-learn">
     Efficient nearest neighbor search with Geopandas and scikit-learn
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#what-did-we-just-do-explanation">
       What did we just do? Explanation.
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#combining-the-neighboring-datasets">
       Combining the neighboring datasets
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#are-the-results-correct-validation">
       Are the results correct? Validation
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#spatial-index-how-to-boost-spatial-queries">
     Spatial index - How to boost spatial queries?
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#id1">
       Motivation
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#spatial-index-with-geopandas">
     Spatial index with Geopandas
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#putting-pieces-together-performance-comparisons">
       Putting pieces together - Performance comparisons
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#counting-the-intersections">
       Counting the intersections
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#note">
       Note
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <section class="tex2jax_ignore mathjax_ignore" id="operations-between-multiple-datasets">
<h1>Operations between multiple datasets<a class="headerlink" href="#operations-between-multiple-datasets" title="Permalink to this headline">#</a></h1>
<ul class="simple">
<li><p>Selecting data based on spatial relationships</p></li>
<li><p>Overlay analysis</p></li>
<li><p>Spatial join, nearest join</p></li>
<li><p>Distance operations</p></li>
<li><p>Spatial index</p></li>
</ul>
<section id="selecting-data-based-on-spatial-relationships">
<h2>Selecting data based on spatial relationships<a class="headerlink" href="#selecting-data-based-on-spatial-relationships" title="Permalink to this headline">#</a></h2>
<p>Finding out if a certain point is located inside or outside of an area,
or finding out if a line intersects with another line or polygon are
fundamental geospatial operations that are often used e.g. to select
data based on location. Such spatial queries are one of the typical
first steps of the workflow when doing spatial analysis. Performing a
spatial join (will be introduced later) between two spatial datasets is
one of the most typical applications where Point in Polygon (PIP) query
is used.</p>
<p>For further reading about PIP and other geometric operations,
see Chapter 4.2 in Smith, Goodchild &amp; Longley: <a class="reference external" href="https://www.spatialanalysisonline.com/HTML/index.html">Geospatial Analysis - 6th edition</a>.</p>
<section id="how-to-check-if-point-is-inside-a-polygon">
<h3>How to check if point is inside a polygon?<a class="headerlink" href="#how-to-check-if-point-is-inside-a-polygon" title="Permalink to this headline">#</a></h3>
<p>Computationally, detecting if a point is inside a polygon is most commonly done using a specific formula called <a class="reference external" href="https://en.wikipedia.org/wiki/Point_in_polygon#Ray_casting_algorithm">Ray Casting algorithm</a>.
Luckily, we do not need to create such a function ourselves for
conducting the Point in Polygon (PIP) query. Instead, we can take
advantage of <a class="reference external" href="https://shapely.readthedocs.io/en/stable/manual.html#binary-predicates">Shapely’s binary predicates</a>
that can evaluate the topolocical relationships between geographical
objects, such as the PIP as we’re interested here.</p>
<p>There are basically two ways of conducting PIP in Shapely:</p>
<ol class="simple">
<li><p>using a function called
<a class="reference external" href="https://shapely.readthedocs.io/en/stable/manual.html#object.within">within()</a>
that checks if a point is within a polygon</p></li>
<li><p>using a function called
<a class="reference external" href="https://shapely.readthedocs.io/en/stable/manual.html#object.contains">contains()</a>
that checks if a polygon contains a point</p></li>
</ol>
<p>Notice: even though we are talking here about <strong>Point</strong> in Polygon
operation, it is also possible to check if a LineString or Polygon is
inside another Polygon.</p>
<p>Let’s import shapely functionalities and create some points:</p>
<!-- #endregion --><div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">shapely.geometry</span> <span class="kn">import</span> <span class="n">Point</span><span class="p">,</span> <span class="n">Polygon</span>

<span class="c1"># Create Point objects</span>
<span class="n">p1</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="mf">24.952242</span><span class="p">,</span> <span class="mf">60.1696017</span><span class="p">)</span>
<span class="n">p2</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="mf">24.976567</span><span class="p">,</span> <span class="mf">60.1612500</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Let’s also create a polygon using a list of coordinate-tuples:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create a Polygon</span>
<span class="n">coords</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">(</span><span class="mf">24.950899</span><span class="p">,</span> <span class="mf">60.169158</span><span class="p">),</span>
    <span class="p">(</span><span class="mf">24.953492</span><span class="p">,</span> <span class="mf">60.169158</span><span class="p">),</span>
    <span class="p">(</span><span class="mf">24.953510</span><span class="p">,</span> <span class="mf">60.170104</span><span class="p">),</span>
    <span class="p">(</span><span class="mf">24.950958</span><span class="p">,</span> <span class="mf">60.169990</span><span class="p">),</span>
<span class="p">]</span>
<span class="n">poly</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Let&#39;s check what we have</span>
<span class="nb">print</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">p2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Let’s check if those points are <code class="docutils literal notranslate"><span class="pre">within</span></code> the polygon:</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Check if p1 is within the polygon using the within function</span>
<span class="n">p1</span><span class="o">.</span><span class="n">within</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Check if p2 is within the polygon</span>
<span class="n">p2</span><span class="o">.</span><span class="n">within</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Okey, so we can see that the first point seems to be inside that polygon
and the other one isn’t.</p>
<p>-In fact, the first point is quite close to close to the center of the polygon as we
can see if we compare the point location to the polygon centroid:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Our point</span>
<span class="nb">print</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span>

<span class="c1"># The centroid</span>
<span class="nb">print</span><span class="p">(</span><span class="n">poly</span><span class="o">.</span><span class="n">centroid</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>It is also possible to do PIP other way around, i.e. to check if
polygon contains a point:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Does polygon contain p1?</span>
<span class="n">poly</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Does polygon contain p2?</span>
<span class="n">poly</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">p2</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Thus, both ways of checking the spatial relationship are identical; <a class="reference external" href="https://shapely.readthedocs.io/en/stable/manual.html#object.contains">contains()</a> is inverse to <a class="reference external" href="https://shapely.readthedocs.io/en/stable/manual.html#object.within">within()</a> and vice versa.</p>
<p>Which one should you use then? Well, it depends:</p>
<ul class="simple">
<li><p>if you have <strong>many points and just one polygon</strong> and you try to find out
which one of them is inside the polygon: You might need to iterate over the points and check one at a time if it
is <strong>within()</strong> the polygon.</p></li>
<li><p>if you have <strong>many polygons and just one point</strong> and you want to find out
which polygon contains the point: You might need to iterate over the polygons until you find a polygon that <strong>contains()</strong> the point specified (assuming there are no overlapping polygons)</p></li>
</ul>
</section>
</section>
<section id="intersect">
<h2>Intersect<a class="headerlink" href="#intersect" title="Permalink to this headline">#</a></h2>
<p>Another typical geospatial operation is to see if a geometry intersects
or touches another one. Again, there are binary operations in Shapely for checking these spatial relationships:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://shapely.readthedocs.io/en/stable/manual.html#object.intersects">intersects():</a> Two objects intersect if the boundary or interior of one object intersect in any way with the boundary or interior of the other object.</p></li>
<li><p><a class="reference external" href="https://shapely.readthedocs.io/en/stable/manual.html#object.touches">touches():</a> Two objects touch if the objects have at least one point in common and their interiors do not intersect with any part of the other object.</p></li>
</ul>
<p>Let’s try these out.</p>
<p>Let’s create two LineStrings:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">shapely.geometry</span> <span class="kn">import</span> <span class="n">LineString</span><span class="p">,</span> <span class="n">MultiLineString</span>

<span class="c1"># Create two lines</span>
<span class="n">line_a</span> <span class="o">=</span> <span class="n">LineString</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])</span>
<span class="n">line_b</span> <span class="o">=</span> <span class="n">LineString</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span>
</pre></div>
</div>
</div>
</div>
<p>Let’s see if they intersect</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">line_a</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">line_b</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Do they also touch?</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">line_a</span><span class="o">.</span><span class="n">touches</span><span class="p">(</span><span class="n">line_b</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Indeed, they do and we can see this by plotting the features together</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create a MultiLineString from line_a and line_b</span>
<span class="n">multi_line</span> <span class="o">=</span> <span class="n">MultiLineString</span><span class="p">([</span><span class="n">line_a</span><span class="p">,</span> <span class="n">line_b</span><span class="p">])</span>
<span class="n">multi_line</span>
</pre></div>
</div>
</div>
</div>
<p>Thus, the <code class="docutils literal notranslate"><span class="pre">line_b</span></code> continues from the same node ( (1,1) ) where <code class="docutils literal notranslate"><span class="pre">line_a</span></code> ends.</p>
<p>However, if the lines overlap fully, they don’t touch due to the spatial relationship rule, as we can see:</p>
<p>Check if <code class="docutils literal notranslate"><span class="pre">line_a</span></code> touches itself:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Does the line touch with itself?</span>
<span class="n">line_a</span><span class="o">.</span><span class="n">touches</span><span class="p">(</span><span class="n">line_a</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>It does not. However, it does intersect:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Does the line intersect with itself?</span>
<span class="n">line_a</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">line_a</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="point-in-polygon-using-geopandas">
<h2>Point in Polygon using Geopandas<a class="headerlink" href="#point-in-polygon-using-geopandas" title="Permalink to this headline">#</a></h2>
<p>Next we will do a practical example where we check which of the addresses from <span class="xref myst">the geocoding tutorial</span> are located in Southern district of Helsinki. Let’s start by reading a KML-file <code class="docutils literal notranslate"><span class="pre">PKS_suuralue.kml</span></code> that has the Polygons for districts of Helsinki Region (data openly available from <a class="reference external" href="http://www.hri.fi/fi/dataset/paakaupunkiseudun-aluejakokartat">Helsinki Region Infoshare</a>.</p>
<p>Let’s start by reading the addresses from the Shapefile that we saved earlier.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">geopandas</span> <span class="k">as</span> <span class="nn">gpd</span>

<span class="n">fp</span> <span class="o">=</span> <span class="s2">&quot;data/addresses.shp&quot;</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>

<span class="n">data</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<section id="reading-kml-files-in-geopandas">
<h3>Reading KML-files in Geopandas<a class="headerlink" href="#reading-kml-files-in-geopandas" title="Permalink to this headline">#</a></h3>
<p>It is possible to read the data from KML-files with GeoPandas in a similar manner as Shapefiles. However, we need to first, enable the KML-driver which is not enabled by default (because KML-files can contain unsupported data structures, nested folders etc., hence be careful when reading KML-files). Supported drivers are managed with <a class="reference external" href="https://github.com/Toblerity/Fiona/blob/master/fiona/drvsupport.py"><code class="docutils literal notranslate"><span class="pre">fiona.supported_drivers</span></code></a>, which is integrated in geopandas. Let’s first check which formats are currently supported:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">geopandas</span> <span class="k">as</span> <span class="nn">gpd</span>

<span class="n">gpd</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">fiona</span><span class="o">.</span><span class="n">drvsupport</span><span class="o">.</span><span class="n">supported_drivers</span>
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Let’s enable the read and write functionalities for KML-driver by passing <code class="docutils literal notranslate"><span class="pre">'rw'</span></code> to whitelist of fiona’s supported drivers:</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gpd</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">fiona</span><span class="o">.</span><span class="n">drvsupport</span><span class="o">.</span><span class="n">supported_drivers</span><span class="p">[</span><span class="s2">&quot;KML&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;rw&quot;</span>
</pre></div>
</div>
</div>
</div>
<p>Let’s check again the supported drivers:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gpd</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">fiona</span><span class="o">.</span><span class="n">drvsupport</span><span class="o">.</span><span class="n">supported_drivers</span>
</pre></div>
</div>
</div>
</div>
<p>Now we should be able to read a KML file using the geopandas <a class="reference external" href="http://geopandas.org/reference/geopandas.read_file.html#geopandas.read_file">read_file()</a> function.</p>
<ul class="simple">
<li><p>Let’s read district polygons from a KML -file that is located in the data-folder:</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Filepath to KML file</span>
<span class="n">fp</span> <span class="o">=</span> <span class="s2">&quot;data/PKS_suuralue.kml&quot;</span>
<span class="n">polys</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">driver</span><span class="o">=</span><span class="s2">&quot;KML&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Check the data</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of rows:&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">polys</span><span class="p">))</span>
<span class="n">polys</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Nice, now we can see that we have 23 districts in our area.
Let’s quickly plot the geometries to see how the layer looks like:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">polys</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>We are interested in an area that is called <code class="docutils literal notranslate"><span class="pre">Eteläinen</span></code> (<em>‘Southern’</em> in English).</p>
<p>Let’s select the <code class="docutils literal notranslate"><span class="pre">Eteläinen</span></code> district and see where it is located on a map:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Select data</span>
<span class="n">southern</span> <span class="o">=</span> <span class="n">polys</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">polys</span><span class="p">[</span><span class="s2">&quot;Name&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;Eteläinen&quot;</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Reset index for the selection</span>
<span class="n">southern</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Check the selction</span>
<span class="n">southern</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Let’s create a map which shows the location of the selected district, and let’s also plot the geocoded address points on top of the map:</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="c1"># Create a figure with one subplot</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>

<span class="c1"># Plot polygons</span>
<span class="n">polys</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">facecolor</span><span class="o">=</span><span class="s2">&quot;gray&quot;</span><span class="p">)</span>
<span class="n">southern</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">facecolor</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">)</span>

<span class="c1"># Plot points</span>
<span class="n">data</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;blue&quot;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>Okey, so we can see that, indeed, certain points are within the selected red Polygon.</p>
<p>Let’s find out which one of them are located within the Polygon. Hence, we are conducting a <strong>Point in Polygon query</strong>.</p>
<p>First, let’s check that we have  <code class="docutils literal notranslate"><span class="pre">shapely.speedups</span></code> enabled. This module makes some of the spatial queries running faster (starting from Shapely version 1.6.0 Shapely speedups are enabled by default):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># import shapely.speedups</span>
<span class="kn">from</span> <span class="nn">shapely</span> <span class="kn">import</span> <span class="n">speedups</span>

<span class="n">speedups</span><span class="o">.</span><span class="n">enabled</span>

<span class="c1"># If false, run this line:</span>
<span class="c1"># shapely.speedups.enable()</span>
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Let’s check which Points are within the <code class="docutils literal notranslate"><span class="pre">southern</span></code> Polygon. Notice, that here we check if the Points are <code class="docutils literal notranslate"><span class="pre">within</span></code> the <strong>geometry</strong>
of the <code class="docutils literal notranslate"><span class="pre">southern</span></code> GeoDataFrame.</p></li>
<li><p>We use the <code class="docutils literal notranslate"><span class="pre">.at[0,</span> <span class="pre">'geometry']</span></code> to parse the actual Polygon geometry object from the GeoDataFrame.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">pip_mask</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">within</span><span class="p">(</span><span class="n">southern</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;geometry&quot;</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">pip_mask</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>As we can see, we now have an array of boolean values for each row, where the result is <code class="docutils literal notranslate"><span class="pre">True</span></code>
if Point was inside the Polygon, and <code class="docutils literal notranslate"><span class="pre">False</span></code> if it was not.</p>
<p>We can now use this mask array to select the Points that are inside the Polygon. Selecting data with this kind of mask array (of boolean values) is easy by passing the array inside the <code class="docutils literal notranslate"><span class="pre">loc</span></code> indexer:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">pip_data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">pip_mask</span><span class="p">]</span>
<span class="n">pip_data</span>
</pre></div>
</div>
</div>
</div>
<p>Let’s finally confirm that our Point in Polygon query worked as it should by plotting the points that are within the southern district:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create a figure with one subplot</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>

<span class="c1"># Plot polygons</span>
<span class="n">polys</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">facecolor</span><span class="o">=</span><span class="s2">&quot;gray&quot;</span><span class="p">)</span>
<span class="n">southern</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">facecolor</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">)</span>

<span class="c1"># Plot points</span>
<span class="n">pip_data</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;gold&quot;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>Perfect! Now we only have the (golden) points that, indeed, are inside the red Polygon which is exactly what we wanted!</p>
</section>
</section>
<section id="overlay-analysis">
<h2>Overlay analysis<a class="headerlink" href="#overlay-analysis" title="Permalink to this headline">#</a></h2>
<p>In this tutorial, the aim is to make an overlay analysis where we create a new layer based on geometries from a dataset that <code class="docutils literal notranslate"><span class="pre">intersect</span></code> with geometries of another layer. As our test case, we will select Polygon grid cells from <code class="docutils literal notranslate"><span class="pre">TravelTimes_to_5975375_RailwayStation_Helsinki.shp</span></code> that intersects with municipality borders of Helsinki found in <code class="docutils literal notranslate"><span class="pre">Helsinki_borders.shp</span></code>.</p>
<p>Typical overlay operations are (source: <a class="reference external" href="https://docs.qgis.org/2.8/en/docs/gentle_gis_introduction/vector_spatial_analysis_buffers.html#more-spatial-analysis-tools">QGIS docs</a>):
<img alt="" src="../../../_images/overlay_operations.png" /></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">geopandas</span> <span class="k">as</span> <span class="nn">gpd</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">shapely.speedups</span>

<span class="o">%</span><span class="k">matplotlib</span> inline

<span class="c1"># File paths</span>
<span class="n">border_fp</span> <span class="o">=</span> <span class="s2">&quot;data/Helsinki_borders.shp&quot;</span>
<span class="n">grid_fp</span> <span class="o">=</span> <span class="s2">&quot;data/TravelTimes_to_5975375_RailwayStation.shp&quot;</span>

<span class="c1"># Read files</span>
<span class="n">grid</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">grid_fp</span><span class="p">)</span>
<span class="n">hel</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">border_fp</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Let’s do a quick overlay visualization of the two layers:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Plot the layers</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">facecolor</span><span class="o">=</span><span class="s2">&quot;gray&quot;</span><span class="p">)</span>
<span class="n">hel</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">facecolor</span><span class="o">=</span><span class="s2">&quot;None&quot;</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s2">&quot;blue&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Here the grey area is the Travel Time Matrix - a data set that contains  13231 grid squares (13231 rows of data) that covers the Helsinki region, and the blue area represents the municipality of Helsinki. Our goal is to conduct an overlay analysis and select the geometries from the grid polygon layer that intersect with the Helsinki municipality polygon.</p>
<p>When conducting overlay analysis, it is important to first check that the CRS of the layers match. The overlay visualization indicates that everything should be ok (the layers are plotted nicely on top of each other). However, let’s still check if the crs match using Python:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Check the crs of the municipality polygon</span>
<span class="nb">print</span><span class="p">(</span><span class="n">hel</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Ensure that the CRS matches, if not raise an AssertionError</span>
<span class="k">assert</span> <span class="n">hel</span><span class="o">.</span><span class="n">crs</span> <span class="o">==</span> <span class="n">grid</span><span class="o">.</span><span class="n">crs</span><span class="p">,</span> <span class="s2">&quot;CRS differs between layers!&quot;</span>
</pre></div>
</div>
</div>
</div>
<p>Indeed, they do. We are now ready to conduct an overlay analysis between these layers.</p>
<p>We will create a new layer based on grid polygons that <code class="docutils literal notranslate"><span class="pre">intersect</span></code> with our Helsinki layer. We can use a function called <code class="docutils literal notranslate"><span class="pre">overlay()</span></code> to conduct the overlay analysis that takes as an input 1) first GeoDataFrame, 2) second GeoDataFrame, and 3) parameter <code class="docutils literal notranslate"><span class="pre">how</span></code> that can be used to control how the overlay analysis is conducted (possible values are <code class="docutils literal notranslate"><span class="pre">'intersection'</span></code>, <code class="docutils literal notranslate"><span class="pre">'union'</span></code>, <code class="docutils literal notranslate"><span class="pre">'symmetric_difference'</span></code>, <code class="docutils literal notranslate"><span class="pre">'difference'</span></code>, and <code class="docutils literal notranslate"><span class="pre">'identity'</span></code>):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">intersection</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">overlay</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">hel</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;intersection&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Let’s plot our data and see what we have:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">intersection</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="s2">&quot;b&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>As a result, we now have only those grid cells that intersect with the Helsinki borders. If you look closely, you can also observe that <strong>the grid cells are clipped based on the boundary.</strong></p>
<ul class="simple">
<li><p>Whatabout the data attributes? Let’s see what we have:</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">intersection</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>As we can see, due to the overlay analysis, the dataset contains the attributes from both input layers.</p>
<p>Let’s save our result grid as a GeoJSON file that is commonly used file format nowadays for storing spatial data.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Output filepath</span>
<span class="n">outfp</span> <span class="o">=</span> <span class="s2">&quot;data/TravelTimes_to_5975375_RailwayStation_Helsinki.geojson&quot;</span>

<span class="c1"># Use GeoJSON driver</span>
<span class="n">intersection</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="n">outfp</span><span class="p">,</span> <span class="n">driver</span><span class="o">=</span><span class="s2">&quot;GeoJSON&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>There are many more examples for different types of overlay analysis in <a class="reference external" href="http://geopandas.org/set_operations.html">Geopandas documentation</a> where you can go and learn more.</p>
</section>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="spatial-join">
<h1>Spatial join<a class="headerlink" href="#spatial-join" title="Permalink to this headline">#</a></h1>
<p><a class="reference external" href="http://wiki.gis.com/wiki/index.php/Spatial_Join">Spatial join</a> is
yet another classic GIS problem. Getting attributes from one layer and
transferring them into another layer based on their spatial relationship
is something you most likely need to do on a regular basis.</p>
<p>In the previous section we learned how to perform <strong>a Point in Polygon query</strong>.
We can now use the same logic to conduct <strong>a spatial join</strong> between two layers based on their
spatial relationship. We could, for example, join the attributes of a polygon layer into a point layer where each point would get the
attributes of a polygon that <code class="docutils literal notranslate"><span class="pre">contains</span></code> the point.</p>
<p>Luckily, <a class="reference external" href="http://geopandas.org/mergingdata.html#spatial-joins">spatial join is already implemented in Geopandas</a>, thus we do not need to create our own function for doing it. There are three possible types of
join that can be applied in spatial join that are determined with <code class="docutils literal notranslate"><span class="pre">op</span></code> -parameter in the <code class="docutils literal notranslate"><span class="pre">gpd.sjoin()</span></code> -function:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;intersects&quot;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;within&quot;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;contains&quot;</span></code></p></li>
</ul>
<p>Sounds familiar? Yep, all of those spatial relationships were discussed
in the <span class="xref myst">Point in Polygon lesson</span>, thus you should know how they work.</p>
<p>Furthermore, pay attention to the different options for the type of join via the <code class="docutils literal notranslate"><span class="pre">how</span></code> parameter; “left”, “right” and “inner”. You can read more about these options in the <a class="reference external" href="http://geopandas.org/mergingdata.html#sjoin-arguments">geopandas sjoin documentation</a> and pandas guide for <a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/merging.html">merge, join and concatenate</a></p>
<p>Let’s perform a spatial join between these two layers:</p>
<ul class="simple">
<li><p><strong>Addresses:</strong> the geocoded address-point (we created this Shapefile in the geocoding tutorial)</p></li>
<li><p><strong>Population grid:</strong> 250m x 250m grid polygon layer that contains population information from the Helsinki Region.</p>
<ul>
<li><p>The population grid a dataset is produced by the <strong>Helsinki Region Environmental
Services Authority (HSY)</strong> (see <a class="reference external" href="https://www.hsy.fi/fi/asiantuntijalle/avoindata/Sivut/AvoinData.aspx?dataID=7">this page</a> to access data from different years).</p></li>
<li><p>You can download the data from <a class="reference external" href="https://www.hsy.fi/sites/AvoinData/AvoinData/SYT/Tietoyhteistyoyksikko/Shape%20(Esri)/V%C3%A4est%C3%B6tietoruudukko/Vaestotietoruudukko_2018_SHP.zip">from this link</a> in the  <a class="reference external" href="https://hri.fi/en_gb/">Helsinki Region Infroshare
(HRI) open data portal</a>.</p></li>
</ul>
</li>
</ul>
<ul class="simple">
<li><p>Here, we will access the data directly from the HSY wfs:</p></li>
</ul>
<!-- #endregion --><div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">geopandas</span> <span class="k">as</span> <span class="nn">gpd</span>
<span class="kn">from</span> <span class="nn">pyproj</span> <span class="kn">import</span> <span class="n">CRS</span>
<span class="kn">import</span> <span class="nn">requests</span>
<span class="kn">import</span> <span class="nn">geojson</span>

<span class="c1"># Specify the url for web feature service</span>
<span class="n">url</span> <span class="o">=</span> <span class="s2">&quot;https://kartta.hsy.fi/geoserver/wfs&quot;</span>

<span class="c1"># Specify parameters (read data in json format).</span>
<span class="c1"># Available feature types in this particular data source: http://geo.stat.fi/geoserver/vaestoruutu/wfs?service=wfs&amp;version=2.0.0&amp;request=describeFeatureType</span>
<span class="n">params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="n">service</span><span class="o">=</span><span class="s2">&quot;WFS&quot;</span><span class="p">,</span>
    <span class="n">version</span><span class="o">=</span><span class="s2">&quot;2.0.0&quot;</span><span class="p">,</span>
    <span class="n">request</span><span class="o">=</span><span class="s2">&quot;GetFeature&quot;</span><span class="p">,</span>
    <span class="n">typeName</span><span class="o">=</span><span class="s2">&quot;asuminen_ja_maankaytto:Vaestotietoruudukko_2018&quot;</span><span class="p">,</span>
    <span class="n">outputFormat</span><span class="o">=</span><span class="s2">&quot;json&quot;</span><span class="p">,</span>
<span class="p">)</span>

<span class="c1"># Fetch data from WFS using requests</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">)</span>

<span class="c1"># Create GeoDataFrame from geojson</span>
<span class="n">pop</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="o">.</span><span class="n">from_features</span><span class="p">(</span><span class="n">geojson</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">content</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>Check the result:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">pop</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>Okey so we have multiple columns in the dataset but the most important
one here is the column <code class="docutils literal notranslate"><span class="pre">asukkaita</span></code> (“population” in Finnish) that
tells the amount of inhabitants living under that polygon.</p>
<ul class="simple">
<li><p>Let’s change the name of that column into <code class="docutils literal notranslate"><span class="pre">pop18</span></code> so that it is
more intuitive. As you might remember, we can easily rename (Geo)DataFrame column names using the <code class="docutils literal notranslate"><span class="pre">rename()</span></code> function where we pass a dictionary of new column names like this: <code class="docutils literal notranslate"><span class="pre">columns={'oldname':</span> <span class="pre">'newname'}</span></code>.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Change the name of a column</span>
<span class="n">pop</span> <span class="o">=</span> <span class="n">pop</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;asukkaita&quot;</span><span class="p">:</span> <span class="s2">&quot;pop18&quot;</span><span class="p">})</span>

<span class="c1"># Check the column names</span>
<span class="n">pop</span><span class="o">.</span><span class="n">columns</span>
</pre></div>
</div>
</div>
</div>
<p>Let’s also get rid of all unnecessary columns by selecting only columns that we need i.e. <code class="docutils literal notranslate"><span class="pre">pop18</span></code> and <code class="docutils literal notranslate"><span class="pre">geometry</span></code></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Subset columns</span>
<span class="n">pop</span> <span class="o">=</span> <span class="n">pop</span><span class="p">[[</span><span class="s2">&quot;pop18&quot;</span><span class="p">,</span> <span class="s2">&quot;geometry&quot;</span><span class="p">]]</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">pop</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>Now we have cleaned the data and have only those columns that we need
for our analysis.</p>
<section id="join-the-layers">
<h2>Join the layers<a class="headerlink" href="#join-the-layers" title="Permalink to this headline">#</a></h2>
<p>Now we are ready to perform the spatial join between the two layers that
we have. The aim here is to get information about <strong>how many people live
in a polygon that contains an individual address-point</strong> . Thus, we want
to join attributes from the population layer we just modified into the
addresses point layer <code class="docutils literal notranslate"><span class="pre">addresses.shp</span></code> that we created trough gecoding in the previous section.</p>
<ul class="simple">
<li><p>Read the addresses layer into memory:</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Addresses filpath</span>
<span class="n">addr_fp</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;data/addresses.shp&quot;</span>

<span class="c1"># Read data</span>
<span class="n">addresses</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">addr_fp</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Check the head of the file</span>
<span class="n">addresses</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>In order to do a spatial join, the layers need to be in the same projection</p>
<ul class="simple">
<li><p>Check the crs of input layers:</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">addresses</span><span class="o">.</span><span class="n">crs</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">pop</span><span class="o">.</span><span class="n">crs</span>
</pre></div>
</div>
</div>
</div>
<p>If the crs information is missing from the population grid, we can <strong>define the coordinate reference system</strong> as <strong>ETRS GK-25 (EPSG:3879)</strong> because we know what it is based on the <a class="reference external" href="https://hri.fi/data/dataset/vaestotietoruudukko">population grid metadata</a>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Define crs</span>
<span class="n">pop</span><span class="o">.</span><span class="n">crs</span> <span class="o">=</span> <span class="n">CRS</span><span class="o">.</span><span class="n">from_epsg</span><span class="p">(</span><span class="mi">3879</span><span class="p">)</span><span class="o">.</span><span class="n">to_wkt</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">pop</span><span class="o">.</span><span class="n">crs</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Are the layers in the same projection?</span>
<span class="n">addresses</span><span class="o">.</span><span class="n">crs</span> <span class="o">==</span> <span class="n">pop</span><span class="o">.</span><span class="n">crs</span>
</pre></div>
</div>
</div>
</div>
<p>Let’s re-project addresses to the projection of the population layer:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">addresses</span> <span class="o">=</span> <span class="n">addresses</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">pop</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Let’s make sure that the coordinate reference system of the layers
are identical</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Check the crs of address points</span>
<span class="nb">print</span><span class="p">(</span><span class="n">addresses</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span>

<span class="c1"># Check the crs of population layer</span>
<span class="nb">print</span><span class="p">(</span><span class="n">pop</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span>

<span class="c1"># Do they match now?</span>
<span class="n">addresses</span><span class="o">.</span><span class="n">crs</span> <span class="o">==</span> <span class="n">pop</span><span class="o">.</span><span class="n">crs</span>
</pre></div>
</div>
</div>
</div>
<p>Now they should be identical. Thus, we can be sure that when doing spatial
queries between layers the locations match and we get the right results
e.g. from the spatial join that we are conducting here.</p>
<ul class="simple">
<li><p>Let’s now join the attributes from <code class="docutils literal notranslate"><span class="pre">pop</span></code> GeoDataFrame into
<code class="docutils literal notranslate"><span class="pre">addresses</span></code> GeoDataFrame by using <code class="docutils literal notranslate"><span class="pre">gpd.sjoin()</span></code> -function:</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Make a spatial join</span>
<span class="n">join</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">sjoin</span><span class="p">(</span><span class="n">addresses</span><span class="p">,</span> <span class="n">pop</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;inner&quot;</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="s2">&quot;within&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">join</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>Awesome! Now we have performed a successful spatial join where we got
two new columns into our <code class="docutils literal notranslate"><span class="pre">join</span></code> GeoDataFrame, i.e. <code class="docutils literal notranslate"><span class="pre">index_right</span></code>
that tells the index of the matching polygon in the population grid and
<code class="docutils literal notranslate"><span class="pre">pop18</span></code> which is the population in the cell where the address-point is
located.</p>
<ul class="simple">
<li><p>Let’s still check how many rows of data we have now:</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">len</span><span class="p">(</span><span class="n">join</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Did we lose some data here?</p>
<ul class="simple">
<li><p>Check how many addresses we had originally:</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">len</span><span class="p">(</span><span class="n">addresses</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>If we plot the layers on top of each other, we can observe that some of the points are located outside the populated grid squares (increase figure size if you can’t see this properly!)</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="c1"># Create a figure with one subplot</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>

<span class="c1"># Plot population grid</span>
<span class="n">pop</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>

<span class="c1"># Plot points</span>
<span class="n">addresses</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Let’s also visualize the joined output:</p>
<p>Plot the points and use the <code class="docutils literal notranslate"><span class="pre">pop18</span></code> column to indicate the color.
<code class="docutils literal notranslate"><span class="pre">cmap</span></code> -parameter tells to use a sequential colormap for the
values, <code class="docutils literal notranslate"><span class="pre">markersize</span></code> adjusts the size of a point, <code class="docutils literal notranslate"><span class="pre">scheme</span></code> parameter can be used to adjust the classification method based on <a class="reference external" href="http://pysal.readthedocs.io/en/latest/library/esda/mapclassify.html">pysal</a>, and <code class="docutils literal notranslate"><span class="pre">legend</span></code> tells that we want to have a legend:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create a figure with one subplot</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>

<span class="c1"># Plot the points with population info</span>
<span class="n">join</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
    <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="s2">&quot;pop18&quot;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s2">&quot;Reds&quot;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">scheme</span><span class="o">=</span><span class="s2">&quot;quantiles&quot;</span><span class="p">,</span> <span class="n">legend</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span>

<span class="c1"># Add title</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Amount of inhabitants living close the the point&quot;</span><span class="p">)</span>

<span class="c1"># Remove white space around the figure</span>
<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>In a similar way, we can plot the original population grid and check the overall population distribution in Helsinki:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create a figure with one subplot</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>

<span class="c1"># Plot the grid with population info</span>
<span class="n">pop</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="s2">&quot;pop18&quot;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s2">&quot;Reds&quot;</span><span class="p">,</span> <span class="n">scheme</span><span class="o">=</span><span class="s2">&quot;quantiles&quot;</span><span class="p">,</span> <span class="n">legend</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># Add title</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Population 2018 in 250 x 250 m grid squares&quot;</span><span class="p">)</span>

<span class="c1"># Remove white space around the figure</span>
<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>Finally, let’s save the result point layer into a file:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Output path</span>
<span class="n">outfp</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;data/addresses_population.shp&quot;</span>

<span class="c1"># Save to disk</span>
<span class="n">join</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="n">outfp</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="spatial-join-nearest">
<h2>Spatial join nearest<a class="headerlink" href="#spatial-join-nearest" title="Permalink to this headline">#</a></h2>
<p>ADD Materials</p>
</section>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="nearest-neighbour-analysis">
<h1>Nearest Neighbour Analysis<a class="headerlink" href="#nearest-neighbour-analysis" title="Permalink to this headline">#</a></h1>
<p>One commonly used GIS task is to be able to find the nearest neighbour for an object or a set of objects. For instance, you might have a single Point object
representing your home location, and then another set of locations representing e.g. public transport stops. Then, quite typical question is <em>“which of the stops is closest one to my home?”</em>
This is a typical nearest neighbour analysis, where the aim is to find the closest geometry to another geometry.</p>
<p>In Python this kind of analysis can be done with shapely function called <code class="docutils literal notranslate"><span class="pre">nearest_points()</span></code> that <a class="reference external" href="https://shapely.readthedocs.io/en/latest/manual.html#shapely.ops.nearest_points">returns a tuple of the nearest points in the input geometries</a>.</p>
<section id="nearest-point-using-shapely">
<h2>Nearest point using Shapely<a class="headerlink" href="#nearest-point-using-shapely" title="Permalink to this headline">#</a></h2>
<p>Let’s start by testing how we can find the nearest Point using the <code class="docutils literal notranslate"><span class="pre">nearest_points()</span></code> function of Shapely.</p>
<ul class="simple">
<li><p>Let’s create an origin Point and a few destination Points and find out the closest destination:</p></li>
</ul>
<!-- #endregion --><div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">shapely.geometry</span> <span class="kn">import</span> <span class="n">Point</span><span class="p">,</span> <span class="n">MultiPoint</span>
<span class="kn">from</span> <span class="nn">shapely.ops</span> <span class="kn">import</span> <span class="n">nearest_points</span>

<span class="c1"># Origin point</span>
<span class="n">orig</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">1.67</span><span class="p">)</span>

<span class="c1"># Destination points</span>
<span class="n">dest1</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1.45</span><span class="p">)</span>
<span class="n">dest2</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">dest3</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>To be able to find out the closest destination point from the origin, we need to create a MultiPoint object from the destination points.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">destinations</span> <span class="o">=</span> <span class="n">MultiPoint</span><span class="p">([</span><span class="n">dest1</span><span class="p">,</span> <span class="n">dest2</span><span class="p">,</span> <span class="n">dest3</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">destinations</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">destinations</span>
</pre></div>
</div>
</div>
</div>
<p>Okey, now we can see that all the destination points are represented as a single MultiPoint object.</p>
<ul class="simple">
<li><p>Now we can find out the nearest destination point by using <code class="docutils literal notranslate"><span class="pre">nearest_points()</span></code> function:</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">nearest_geoms</span> <span class="o">=</span> <span class="n">nearest_points</span><span class="p">(</span><span class="n">orig</span><span class="p">,</span> <span class="n">destinations</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>We can check the data type of this object and confirm that the <code class="docutils literal notranslate"><span class="pre">nearest_points()</span></code> function returns a tuple of nearest points:</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span><span class="p">(</span><span class="n">nearest_geoms</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>let’s check the contents of this tuple:</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">nearest_geoms</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">nearest_geoms</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">nearest_geoms</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<p>In the tuple, the first item (at index 0) is the geometry of our origin point and the second item (at index 1) is the actual nearest geometry from the destination points. Hence, the closest destination point seems to be the one located at coordinates (0, 1.45).</p>
<p>This is the basic logic how we can find the nearest point from a set of points.</p>
</section>
<section id="nearest-points-using-geopandas">
<h2>Nearest points using Geopandas<a class="headerlink" href="#nearest-points-using-geopandas" title="Permalink to this headline">#</a></h2>
<p>Let’s then see how it is possible to find nearest points from a set of origin points to a set of destination points using GeoDataFrames. Here, we will use the <code class="docutils literal notranslate"><span class="pre">PKS_suuralueet.kml</span></code> district data, and the <code class="docutils literal notranslate"><span class="pre">addresses.shp</span></code> address points from previous sections.</p>
<p><strong>Our goal in this tutorial is to find out the closest address to the centroid of each district.</strong></p>
<ul class="simple">
<li><p>Let’s first read in the data and check their structure:</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Import geopandas</span>
<span class="kn">import</span> <span class="nn">geopandas</span> <span class="k">as</span> <span class="nn">gpd</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Define filepaths</span>
<span class="n">fp1</span> <span class="o">=</span> <span class="s2">&quot;data/PKS_suuralue.kml&quot;</span>
<span class="n">fp2</span> <span class="o">=</span> <span class="s2">&quot;data/addresses.shp&quot;</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Enable KML driver</span>
<span class="n">gpd</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">fiona</span><span class="o">.</span><span class="n">drvsupport</span><span class="o">.</span><span class="n">supported_drivers</span><span class="p">[</span><span class="s2">&quot;KML&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;rw&quot;</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Read in data with geopandas</span>
<span class="n">df1</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">fp1</span><span class="p">,</span> <span class="n">driver</span><span class="o">=</span><span class="s2">&quot;KML&quot;</span><span class="p">)</span>
<span class="n">df2</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">fp2</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># District polygons:</span>
<span class="n">df1</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Address points:</span>
<span class="n">df2</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>Before calculating any distances, we should re-project the data into a projected crs.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">df1</span> <span class="o">=</span> <span class="n">df1</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">epsg</span><span class="o">=</span><span class="mi">3067</span><span class="p">)</span>
<span class="n">df2</span> <span class="o">=</span> <span class="n">df2</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">epsg</span><span class="o">=</span><span class="mi">3067</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Furthermore, let’s calculate the centroids for each district area:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">df1</span><span class="p">[</span><span class="s2">&quot;centroid&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df1</span><span class="o">.</span><span class="n">centroid</span>
<span class="n">df1</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>SO, for each row of data in the disctricts -table, we want to figure out the nearest address point and fetch some attributes related to that point. In other words, we want to apply the Shapely <code class="docutils literal notranslate"><span class="pre">nearest_points</span></code>function so that we compare each polygon centroid to all address points, and based on this information access correct attribute information from the address table.</p>
<p>For doing this, we can create a function that we will apply on the polygon GeoDataFrame:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_nearest_values</span><span class="p">(</span>
    <span class="n">row</span><span class="p">,</span> <span class="n">other_gdf</span><span class="p">,</span> <span class="n">point_column</span><span class="o">=</span><span class="s2">&quot;geometry&quot;</span><span class="p">,</span> <span class="n">value_column</span><span class="o">=</span><span class="s2">&quot;geometry&quot;</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Find the nearest point and return the corresponding value from specified value column.&quot;&quot;&quot;</span>

    <span class="c1"># Create an union of the other GeoDataFrame&#39;s geometries:</span>
    <span class="n">other_points</span> <span class="o">=</span> <span class="n">other_gdf</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unary_union</span>

    <span class="c1"># Find the nearest points</span>
    <span class="n">nearest_geoms</span> <span class="o">=</span> <span class="n">nearest_points</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">point_column</span><span class="p">],</span> <span class="n">other_points</span><span class="p">)</span>

    <span class="c1"># Get corresponding values from the other df</span>
    <span class="n">nearest_data</span> <span class="o">=</span> <span class="n">other_gdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">other_gdf</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">nearest_geoms</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

    <span class="n">nearest_value</span> <span class="o">=</span> <span class="n">nearest_data</span><span class="p">[</span><span class="n">value_column</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">nearest_value</span>
</pre></div>
</div>
</div>
</div>
<p>By default, this function returns the geometry of the nearest point for each row. It is also possible to fetch information from other columns by changing the <code class="docutils literal notranslate"><span class="pre">value_column</span></code> parameter.</p>
<p>The function creates a MultiPoint object from <code class="docutils literal notranslate"><span class="pre">other_gdf</span></code> geometry column (in our case, the address points) and further passes this MultiPoint object to Shapely’s <code class="docutils literal notranslate"><span class="pre">nearest_points</span></code> function.</p>
<p>Here, we are using a method for creating an union of all input geometries called <code class="docutils literal notranslate"><span class="pre">unary_union</span></code>.</p>
<ul class="simple">
<li><p>Let’s check how unary union works by applying it to the address points GeoDataFrame:</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">unary_union</span> <span class="o">=</span> <span class="n">df2</span><span class="o">.</span><span class="n">unary_union</span>
<span class="nb">print</span><span class="p">(</span><span class="n">unary_union</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Okey now we are ready to use our function and find closest address point for each polygon centroid.</p>
<ul class="simple">
<li><p>Try first applying the function without any additional modifications:</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">df1</span><span class="p">[</span><span class="s2">&quot;nearest_loc&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df1</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
    <span class="n">get_nearest_values</span><span class="p">,</span> <span class="n">other_gdf</span><span class="o">=</span><span class="n">df2</span><span class="p">,</span> <span class="n">point_column</span><span class="o">=</span><span class="s2">&quot;centroid&quot;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Finally, we can specify that we want the <code class="docutils literal notranslate"><span class="pre">id</span></code> -column for each point, and store the output in a new column <code class="docutils literal notranslate"><span class="pre">&quot;nearest_loc&quot;</span></code>:</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">df1</span><span class="p">[</span><span class="s2">&quot;nearest_loc&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df1</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
    <span class="n">get_nearest_values</span><span class="p">,</span>
    <span class="n">other_gdf</span><span class="o">=</span><span class="n">df2</span><span class="p">,</span>
    <span class="n">point_column</span><span class="o">=</span><span class="s2">&quot;centroid&quot;</span><span class="p">,</span>
    <span class="n">value_column</span><span class="o">=</span><span class="s2">&quot;id&quot;</span><span class="p">,</span>
    <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">df1</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>That’s it! Now we found the closest point for each centroid and got the <code class="docutils literal notranslate"><span class="pre">id</span></code> value from our addresses into the <code class="docutils literal notranslate"><span class="pre">df1</span></code> GeoDataFrame.</p>
</section>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="nearest-neighbor-analysis-with-large-datasets">
<h1>Nearest neighbor analysis with large datasets<a class="headerlink" href="#nearest-neighbor-analysis-with-large-datasets" title="Permalink to this headline">#</a></h1>
<p>While Shapely’s <code class="docutils literal notranslate"><span class="pre">nearest_points</span></code> -function provides a nice and easy way of conducting the nearest neighbor analysis, it can be quite slow. Using it also requires taking the <code class="docutils literal notranslate"><span class="pre">unary</span> <span class="pre">union</span></code> of the point dataset where all the Points are merged into a single layer. This can be a really memory hungry and slow operation, that can cause problems with large point datasets.</p>
<p>Luckily, there is a much faster and memory efficient alternatives for conducting nearest neighbor analysis, based on a function called <a class="reference external" href="https://en.wikipedia.org/wiki/Ball_tree">BallTree</a> from a <a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.BallTree.html">scikit-learn</a> library. The Balltree algorithm has some nice features, such as the ability to calculate the distance between neighbors with various different distance metrics. Most importantly the function allows to calculate <code class="docutils literal notranslate"><span class="pre">euclidian</span></code> distance between neighbors (good if your data is in metric crs), as well as <code class="docutils literal notranslate"><span class="pre">haversine</span></code> distance which allows to determine <a class="reference external" href="https://en.wikipedia.org/wiki/Great-circle_distance">Great Circle distances</a> between locations (good if your data is in lat/lon format). <em>Note: There is also an algorithm called <a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.KDTree.html#sklearn.neighbors.KDTree">KDTree</a> in scikit-learn, that is also highly efficient but less flexible in terms of supported distance metrics.</em></p>
<section id="motivation">
<h2>Motivation<a class="headerlink" href="#motivation" title="Permalink to this headline">#</a></h2>
<p>In this tutorial, we go through a very practical example that relates to our daily commute: Where is the closest public transport stop from my place of living? Hence, our aim is to search for each building in Helsinki Region (around 159 000 buildings) the closest public transport stop (~ 8400 stops). The building points have been fetched from OpenStreetMap using a library called <a class="reference external" href="https://github.com/gboeing/osmnx">OSMnx</a> (we will learn more about this library later), and the public transport stops have been fetched from open <a class="reference external" href="https://transitfeeds.com/p/helsinki-regional-transport/735">GTFS dataset for Helsinki Region</a> that contains information about public transport stops, schedules etc.</p>
</section>
<section id="efficient-nearest-neighbor-search-with-geopandas-and-scikit-learn">
<h2>Efficient nearest neighbor search with Geopandas and scikit-learn<a class="headerlink" href="#efficient-nearest-neighbor-search-with-geopandas-and-scikit-learn" title="Permalink to this headline">#</a></h2>
<p>The following examples show how to conduct nearest neighbor analysis efficiently with large datasets. We will first define the functions and see how to use them, and then we go through the code to understand what happened.</p>
<ul class="simple">
<li><p>Let’s first read the datasets into Geopandas. In case of reading the building data, we will here learn a trick how to read the data directly from a ZipFile. It is very practical to know how to do this, as compressing large datasets is a very common procedure.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">geopandas</span> <span class="k">as</span> <span class="nn">gpd</span>
<span class="kn">from</span> <span class="nn">zipfile</span> <span class="kn">import</span> <span class="n">ZipFile</span>
<span class="kn">import</span> <span class="nn">io</span>


<span class="k">def</span> <span class="nf">read_gdf_from_zip</span><span class="p">(</span><span class="n">zip_fp</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reads a spatial dataset from ZipFile into GeoPandas. Assumes that there is only a single file (such as GeoPackage)</span>
<span class="sd">    inside the ZipFile.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="n">ZipFile</span><span class="p">(</span><span class="n">zip_fp</span><span class="p">)</span> <span class="k">as</span> <span class="n">z</span><span class="p">:</span>
        <span class="c1"># Lists all files inside the ZipFile, here assumes that there is only a single file inside</span>
        <span class="n">layer</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">namelist</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">layer</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">data</span>


<span class="c1"># Filepaths</span>
<span class="n">stops</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="s2">&quot;data/pt_stops_helsinki.gpkg&quot;</span><span class="p">)</span>
<span class="n">buildings</span> <span class="o">=</span> <span class="n">read_gdf_from_zip</span><span class="p">(</span><span class="s2">&quot;data/building_points_helsinki.zip&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Let’s see how our datasets look like:</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">buildings</span><span class="o">.</span><span class="n">head</span><span class="p">(),</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">--------&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">stops</span><span class="o">.</span><span class="n">head</span><span class="p">())</span>
</pre></div>
</div>
</div>
</div>
<p>Okay, so both of our datasets consisting points, and based on the coordinates, they seem to be in WGS84 projection.</p>
<ul class="simple">
<li><p>Let’s also make maps out of them to get a better understanding of the data</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="k">matplotlib</span> inline
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">nrows</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ncols</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>

<span class="c1"># Plot buildings</span>
<span class="n">buildings</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">markersize</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Buildings&quot;</span><span class="p">)</span>

<span class="c1"># Plot stops</span>
<span class="n">stops</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">markersize</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Stops&quot;</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
<p>As we can see, we have a very densely distributed Point dataset that shows the location of the buildings (their centroid) in Helsinki Region. On the right, we have public transport stops that seem to cover a bit broader geographical extent with a few train stops reaching further North. Most importantly, we can see from the coordinates and the map that both of the layers share the same coordinate reference system, and they are approximately from the same geographical region. Hence, we are ready to find closest public transport stop (on the right) for each building on the left map.</p>
<ul class="simple">
<li><p>Let’s first prepare a couple of functions that does the work</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="kn">import</span> <span class="n">BallTree</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>


<span class="k">def</span> <span class="nf">get_nearest</span><span class="p">(</span><span class="n">src_points</span><span class="p">,</span> <span class="n">candidates</span><span class="p">,</span> <span class="n">k_neighbors</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Find nearest neighbors for all source points from a set of candidate points&quot;&quot;&quot;</span>

    <span class="c1"># Create tree from the candidate points</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="n">BallTree</span><span class="p">(</span><span class="n">candidates</span><span class="p">,</span> <span class="n">leaf_size</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;haversine&quot;</span><span class="p">)</span>

    <span class="c1"># Find closest points and distances</span>
    <span class="n">distances</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">src_points</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k_neighbors</span><span class="p">)</span>

    <span class="c1"># Transpose to get distances and indices into arrays</span>
    <span class="n">distances</span> <span class="o">=</span> <span class="n">distances</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">indices</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>

    <span class="c1"># Get closest indices and distances (i.e. array at index 0)</span>
    <span class="c1"># note: for the second closest points, you would take index 1, etc.</span>
    <span class="n">closest</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">closest_dist</span> <span class="o">=</span> <span class="n">distances</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Return indices and distances</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">closest</span><span class="p">,</span> <span class="n">closest_dist</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">nearest_neighbor</span><span class="p">(</span><span class="n">left_gdf</span><span class="p">,</span> <span class="n">right_gdf</span><span class="p">,</span> <span class="n">return_dist</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    For each point in left_gdf, find closest point in right GeoDataFrame and return them.</span>

<span class="sd">    NOTICE: Assumes that the input Points are in WGS84 projection (lat/lon).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">left_geom_col</span> <span class="o">=</span> <span class="n">left_gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">name</span>
    <span class="n">right_geom_col</span> <span class="o">=</span> <span class="n">right_gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">name</span>

    <span class="c1"># Ensure that index in right gdf is formed of sequential numbers</span>
    <span class="n">right</span> <span class="o">=</span> <span class="n">right_gdf</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Parse coordinates from points and insert them into a numpy array as RADIANS</span>
    <span class="c1"># Notice: should be in Lat/Lon format</span>
    <span class="n">left_radians</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="n">left_gdf</span><span class="p">[</span><span class="n">left_geom_col</span><span class="p">]</span>
        <span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">geom</span><span class="p">:</span> <span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">180</span><span class="p">,</span> <span class="n">geom</span><span class="o">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">180</span><span class="p">))</span>
        <span class="o">.</span><span class="n">to_list</span><span class="p">()</span>
    <span class="p">)</span>
    <span class="n">right_radians</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="n">right</span><span class="p">[</span><span class="n">right_geom_col</span><span class="p">]</span>
        <span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">geom</span><span class="p">:</span> <span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">180</span><span class="p">,</span> <span class="n">geom</span><span class="o">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">180</span><span class="p">))</span>
        <span class="o">.</span><span class="n">to_list</span><span class="p">()</span>
    <span class="p">)</span>

    <span class="c1"># Find the nearest points</span>
    <span class="c1"># -----------------------</span>
    <span class="c1"># closest ==&gt; index in right_gdf that corresponds to the closest point</span>
    <span class="c1"># dist ==&gt; distance between the nearest neighbors (in meters)</span>

    <span class="n">closest</span><span class="p">,</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">get_nearest</span><span class="p">(</span><span class="n">src_points</span><span class="o">=</span><span class="n">left_radians</span><span class="p">,</span> <span class="n">candidates</span><span class="o">=</span><span class="n">right_radians</span><span class="p">)</span>

    <span class="c1"># Return points from right GeoDataFrame that are closest to points in left GeoDataFrame</span>
    <span class="n">closest_points</span> <span class="o">=</span> <span class="n">right</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">closest</span><span class="p">]</span>

    <span class="c1"># Ensure that the index corresponds the one in left_gdf</span>
    <span class="n">closest_points</span> <span class="o">=</span> <span class="n">closest_points</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Add distance if requested</span>
    <span class="k">if</span> <span class="n">return_dist</span><span class="p">:</span>
        <span class="c1"># Convert to meters from radians</span>
        <span class="n">earth_radius</span> <span class="o">=</span> <span class="mi">6371000</span>  <span class="c1"># meters</span>
        <span class="n">closest_points</span><span class="p">[</span><span class="s2">&quot;distance&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist</span> <span class="o">*</span> <span class="n">earth_radius</span>

    <span class="k">return</span> <span class="n">closest_points</span>
</pre></div>
</div>
</div>
</div>
<p>Okay, now we have our functions defined. So let’s use them and find the nearest neighbors!</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Find closest public transport stop for each building and get also the distance based on haversine distance</span>
<span class="c1"># Note: haversine distance which is implemented here is a bit slower than using e.g. &#39;euclidean&#39; metric</span>
<span class="c1"># but useful as we get the distance between points in meters</span>
<span class="n">closest_stops</span> <span class="o">=</span> <span class="n">nearest_neighbor</span><span class="p">(</span><span class="n">buildings</span><span class="p">,</span> <span class="n">stops</span><span class="p">,</span> <span class="n">return_dist</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># And the result looks like ..</span>
<span class="n">closest_stops</span>
</pre></div>
</div>
</div>
</div>
<p>Great, that didn’t take too long! Especially considering that we had quite a few points in our datasets (8400*159000=1.33 billion connections). As a result, we have a new GeoDataFrame that reminds a lot the original <code class="docutils literal notranslate"><span class="pre">stops</span></code> dataset. However, as we can see there are much more rows than in the original dataset, and in fact, each row in this dataset corresponds to a single building in the <code class="docutils literal notranslate"><span class="pre">buildings</span></code> dataset. Hence, we should have exactly the same number of closest_stops as there are buildings. Let’s confirm this:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Now we should have exactly the same number of closest_stops as we have buildings</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">closest_stops</span><span class="p">),</span> <span class="s2">&quot;==&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">buildings</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>Indeed, that seems to be the case. Hence, it is easy to combine these two datasets together. Before continuing our analysis, let’s take a bit deeper look, what we actually did with the functions above.</p>
<section id="what-did-we-just-do-explanation">
<h3>What did we just do? Explanation.<a class="headerlink" href="#what-did-we-just-do-explanation" title="Permalink to this headline">#</a></h3>
<p>To get a bit more understanding of what just happened, let’s go through the essential parts of the two functions we defined earlier, i.e. <code class="docutils literal notranslate"><span class="pre">nearest_neighbor()</span></code> and <code class="docutils literal notranslate"><span class="pre">get_closest()</span></code>.</p>
<p>The purpose of <code class="docutils literal notranslate"><span class="pre">nearest_neighbor()</span></code> function is to handle and transform the data from GeoDataFrame into <code class="docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">arrays</span></code> (=super-fast data structure) in a format how <code class="docutils literal notranslate"><span class="pre">BallTree</span></code> function wants them. This includes converting the lat/lon coordinates into radians (and back), so that we get the distances between the neighboring points in a correct format: scikit-learn’s <a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.DistanceMetric.html">haversine distance metric</a> wants inputs as radians and also outputs the data as radians. To convert a lat/lon coordinate to radian, we use formula: <code class="docutils literal notranslate"><span class="pre">Radian</span> <span class="pre">=</span> <span class="pre">Degree</span> <span class="pre">*</span> <span class="pre">PI</span> <span class="pre">/</span> <span class="pre">180</span></code>. By doing this, we are able to get the output distance information in meters (even if our coordinates are in decimal degrees).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">get_closest()</span></code> function does the actual nearest neighbor search using <a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.BallTree.html">BallTree</a> function. We initialize the <code class="docutils literal notranslate"><span class="pre">BallTree</span></code> object with the coordinate information from the <strong>right_gdf</strong> (i.e. the point dataset that contains all the nearest neighbor candidates), and we specify the distance metric to be <code class="docutils literal notranslate"><span class="pre">haversine</span></code> so that we get the Great Circle Distances. The <code class="docutils literal notranslate"><span class="pre">leaf_size</span></code> parameter adjusts the tradeoff between the cost of BallTree node traversal and the cost of a brute-force distance estimate. Changing leaf_size will not affect the results of a query, but can significantly impact the speed of a query and the memory required to store the constructed tree. We determine the leaf_size as 15 which has been found to be a good compromise when <a class="reference external" href="https://jakevdp.github.io/blog/2013/04/29/benchmarking-nearest-neighbor-searches-in-python/">benchmarked</a>. After we have built (initialized) the ball-tree, we run the nearest neighbor query with <code class="docutils literal notranslate"><span class="pre">tree.query(src_points,</span> <span class="pre">k=k_neighbors)</span></code>, where the src_points are the building-coordinates (as radians) and the <code class="docutils literal notranslate"><span class="pre">k</span></code> -parameter is the number of neighbors we want to calculate (1 in our case as we are only interested in the closest neighbor). Finally, we just re-arrange the data back into a format in which the closest point indices and distances are in separate numpy arrays.</p>
<p><strong>Note:</strong> The functions here assume that your input points are in WGS84 projection. If you pass the points in some other projection, it is highly likely that the distances between nearest neighbors are incorrect. Determining which is the nearest neighbor should not be affected, though.</p>
</section>
<section id="combining-the-neighboring-datasets">
<h3>Combining the neighboring datasets<a class="headerlink" href="#combining-the-neighboring-datasets" title="Permalink to this headline">#</a></h3>
<p>Okay, now as we have found closest stop for each building in the region, we can easily merge the information about closest stops back to the building layer. The order of the <code class="docutils literal notranslate"><span class="pre">closest_stops</span></code> matches exactly the order in <code class="docutils literal notranslate"><span class="pre">buildings</span></code>, so we can easily merge the datasets based on index.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Rename the geometry of closest stops gdf so that we can easily identify it</span>
<span class="n">closest_stops</span> <span class="o">=</span> <span class="n">closest_stops</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;geometry&quot;</span><span class="p">:</span> <span class="s2">&quot;closest_stop_geom&quot;</span><span class="p">})</span>

<span class="c1"># Merge the datasets by index (for this, it is good to use &#39;.join()&#39; -function)</span>
<span class="n">buildings</span> <span class="o">=</span> <span class="n">buildings</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">closest_stops</span><span class="p">)</span>

<span class="c1"># Let&#39;s see what we have</span>
<span class="n">buildings</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>Excellent! Now we have useful information for each building about the closest stop including the <code class="docutils literal notranslate"><span class="pre">distance</span></code> (in meters) and also e.g. the name of the stop in <code class="docutils literal notranslate"><span class="pre">stop_name</span></code> column.</p>
<ul class="simple">
<li><p>Now it is easy to do some descriptive analysis based on this dataset, that gives information about levels of access to public transport in the region:</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">buildings</span><span class="p">[</span><span class="s2">&quot;distance&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">describe</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>Okay, as we can see the average distance to public transport in the region is around 300 meters. More than 75 % of the buildings seem to be within within 5 minute walking time (~370 meters with walking speed of 4.5 kmph) which indicates generally a good situation in terms of accessibility levels in the region overall. There seem to be some really remote buildings in the data as well, as the longest distance to closest public transport stop is more than 7 kilometers.</p>
<ul class="simple">
<li><p>Let’s make a map out of the distance information to see if there are some spatial patterns in the data in terms of accessibility levels:</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">buildings</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
    <span class="n">column</span><span class="o">=</span><span class="s2">&quot;distance&quot;</span><span class="p">,</span>
    <span class="n">markersize</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span>
    <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
    <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span>
    <span class="n">scheme</span><span class="o">=</span><span class="s2">&quot;quantiles&quot;</span><span class="p">,</span>
    <span class="n">k</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
    <span class="n">legend</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Okay, as we can see, there are some clear spatial patterns in the levels of access to public transport. The buildings with the shortest distances (i.e. best accessibility) are located in the densely populated areas, whereas the buildings locating in the periferial areas (such as islands on the South, and nature areas in the North-West) tend to have longer distance to public transport.</p>
</section>
<section id="are-the-results-correct-validation">
<h3>Are the results correct? Validation<a class="headerlink" href="#are-the-results-correct-validation" title="Permalink to this headline">#</a></h3>
<p>As a final step, it’s good to ensure that our functions are working as they should. This can be done easily by examining the data visually.</p>
<ul class="simple">
<li><p>Let’s first create LineStrings between the building and closest stop points:</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">shapely.geometry</span> <span class="kn">import</span> <span class="n">LineString</span>

<span class="c1"># Create a link (LineString) between building and stop points</span>
<span class="n">buildings</span><span class="p">[</span><span class="s2">&quot;link&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">buildings</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
    <span class="k">lambda</span> <span class="n">row</span><span class="p">:</span> <span class="n">LineString</span><span class="p">([</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;closest_stop_geom&quot;</span><span class="p">]]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
<span class="p">)</span>

<span class="c1"># Set link as the active geometry</span>
<span class="n">building_links</span> <span class="o">=</span> <span class="n">buildings</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">building_links</span> <span class="o">=</span> <span class="n">building_links</span><span class="o">.</span><span class="n">set_geometry</span><span class="p">(</span><span class="s2">&quot;link&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Let’s now visualize the building points, stops and the links, and zoom to certain area so that we can investigate the results, and confirm that everything looks correct.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Plot the connecting links between buildings and stops and color them based on distance</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">building_links</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
    <span class="n">column</span><span class="o">=</span><span class="s2">&quot;distance&quot;</span><span class="p">,</span>
    <span class="n">cmap</span><span class="o">=</span><span class="s2">&quot;Greens&quot;</span><span class="p">,</span>
    <span class="n">scheme</span><span class="o">=</span><span class="s2">&quot;quantiles&quot;</span><span class="p">,</span>
    <span class="n">k</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
    <span class="n">alpha</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span>
    <span class="n">lw</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span>
    <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span>
<span class="p">)</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">buildings</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;yellow&quot;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">stops</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;o&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

<span class="c1"># Zoom closer</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="mf">24.99</span><span class="p">,</span> <span class="mf">25.01</span><span class="p">])</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="mf">60.26</span><span class="p">,</span> <span class="mf">60.275</span><span class="p">])</span>

<span class="c1"># Set map background color to black, which helps with contrast</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_facecolor</span><span class="p">(</span><span class="s2">&quot;black&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Voilá, these weird star looking shapes are formed around public transport stops (red) where each link is associated buildings (yellow points) that are closest to the given stop. The color intensity varies according the distance between the stops and buildings. Based on this figure we can conclude that our nearest neighbor search was succesfull and worked as planned.</p>
</section>
</section>
<section id="spatial-index-how-to-boost-spatial-queries">
<h2>Spatial index - How to boost spatial queries?<a class="headerlink" href="#spatial-index-how-to-boost-spatial-queries" title="Permalink to this headline">#</a></h2>
<p>While using the technique from previous examples produces correct results, it is in fact quite slow from performance point of view. Especially when having large datasets (quite typical nowadays), the point in polygon queries can become frustratingly slow, which can be a nerve-racking experience for a busy geo-data scientist.</p>
<p>Luckily there is an easy and widely used solution called <strong>spatial index</strong> that can significantly boost the performance of your spatial queries. Various alternative techniques has been developed to boost spatial queries, but one of the most popular one and widely used is a spatial index based on <a class="reference external" href="https://en.wikipedia.org/wiki/R-tree">R-tree</a> data structure.</p>
<p>The core idea behind the <strong>R-tree</strong> is to form a tree-like data structure where nearby objects are grouped together, and their geographical extent (minimum bounding box) is inserted into the data structure (i.e. R-tree). This bounding box then represents the whole group of geometries as one level (typically called as “page” or “node”) in the data structure. This process is repeated several times, which produces a tree-like structure where different levels are connected to each other. This structure makes the query times for finding a single object from the data much faster, as the algorithm does not need to travel through all geometries in the data. In the example below, we can see how the geometries have been grouped into several sub-groups (lower part of the picture) and inserted into a tree structure (upper part) where there exists two groups on the highest level (<code class="docutils literal notranslate"><span class="pre">R1</span></code> and <code class="docutils literal notranslate"><span class="pre">R2</span></code>), which are again grouped into five lower level groups (<code class="docutils literal notranslate"><span class="pre">R3-R7</span></code>):</p>
<p><img alt="Rtree" src="../../../_images/Rtree-IBM.png" />
Simple example of an R-tree for 2D rectanges (source: <a class="reference external" href="https://www.ibm.com/support/knowledgecenter/en/SSGU8G_11.50.0/com.ibm.rtree.doc/sii-overview-27706.htm">IBM</a>)</p>
<p>In the next tutorial we will learn how to significantly improve the query times for finding points that are within a given polygon. We will use data that represents all road intersections in the Uusimaa Region of Finland, and count the number of intersections on a postal code level. <em>Why would you do such a thing?</em>, well, one could for example try to understand the vitality of city blocks following <a class="reference external" href="https://en.wikipedia.org/wiki/Jane_Jacobs">Jane Jacobs’</a> ideas.</p>
<section id="id1">
<h3>Motivation<a class="headerlink" href="#id1" title="Permalink to this headline">#</a></h3>
<p>As a motivation for counting intersections, we can use an example/theory from <a class="reference external" href="https://en.wikipedia.org/wiki/Jane_Jacobs">Jane Jacobs’</a> classic book <a class="reference external" href="https://en.wikipedia.org/wiki/The_Death_and_Life_of_Great_American_Cities">“The Death and Life of Great American Cities”</a> (1961), where she defines four requirements
that makes a vital/vibrant city:</p>
<ol class="simple">
<li><p>“The district, and indeed as many of its internal parts as possible, must serve more than one primary function; preferably more than two.
These must insure the presence of people who go outdoors on different schedules and are in the place for different purposes,
but who are able to use many facilities in common.” <em>(–&gt; One could use e.g. OSM data to understand the diversity of services etc.)</em></p></li>
<li><p>“Most blocks must be short; that is, streets and <strong>opportunities to turn corners</strong> must be frequent.” –&gt; intersections!</p></li>
<li><p>“The district must mingle buildings that vary in age and condition, including a good proportion of old ones so that they vary in the economic yield they must produce. This mingling must be fairly close-grained.” (–&gt; one could use e.g. existing building datasets that are available for many cities in Finland)</p></li>
<li><p>“There must be a sufficiently dence concentration of people, for whatever purposes they may be there. This includes dence concentration in the case of people who are there because of residence.”</p></li>
</ol>
<p>The following tutorial only covers one aspect of these four (2.), but it certainly would be possible to measure all 4 aspects if combining more datasets together.</p>
</section>
</section>
<section id="spatial-index-with-geopandas">
<h2>Spatial index with Geopandas<a class="headerlink" href="#spatial-index-with-geopandas" title="Permalink to this headline">#</a></h2>
<p>In this tutorial, we will first go through a step by step example showing how spatial index works, and in the end we put things together and produce a practical function for doing fast spatial queries.</p>
<ul class="simple">
<li><p>Let’s start by reading data representing road intersections (parsed from <a class="reference external" href="https://vayla.fi/web/en/open-data/digiroad/data#.Xca1TzP7Q2w">Digiroad road network data</a>) and postal code areas (obtained from <a class="reference external" href="https://www.tilastokeskus.fi/tup/karttaaineistot/postinumeroalueet.html">Statistics Finland</a>). In this time, we will read the data from Geopackage files:</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">geopandas</span> <span class="k">as</span> <span class="nn">gpd</span>

<span class="c1"># Filepaths</span>
<span class="n">intersections_fp</span> <span class="o">=</span> <span class="s2">&quot;data/uusimaa_intersections.gpkg&quot;</span>
<span class="n">postcode_areas_fp</span> <span class="o">=</span> <span class="s2">&quot;data/uusimaa_postal_code_areas.gpkg&quot;</span>

<span class="n">intersections</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">intersections_fp</span><span class="p">)</span>
<span class="n">postcode_areas</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">postcode_areas_fp</span><span class="p">)</span>

<span class="c1"># Let&#39;s check first rows</span>
<span class="nb">print</span><span class="p">(</span><span class="n">intersections</span><span class="o">.</span><span class="n">head</span><span class="p">(),</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">-------&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">postcode_areas</span><span class="o">.</span><span class="n">head</span><span class="p">())</span>
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Let’s see how many intersections and postal code areas we have:</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of intersections:&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">intersections</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of postal code areas:&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">postcode_areas</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>Okay, as we can see there are 63.5 thousand intersections in the region and 370 postal code areas. These are not yet huge datasets, but big enough so that we can see the benefits in using a spatial index.</p>
<ul class="simple">
<li><p>Let’s still explore quickly how our datasets look on a map before doing the point in polygon queries.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="k">matplotlib</span> inline
<span class="n">ax</span> <span class="o">=</span> <span class="n">postcode_areas</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">intersections</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;yellow&quot;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

<span class="c1"># Zoom to closer (comment out the following to see the full extent of the data)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="mi">380000</span><span class="p">,</span> <span class="mi">395000</span><span class="p">])</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="mi">6667500</span><span class="p">,</span> <span class="mi">6680000</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<p>As we can see from the map, we have a large number of points (intersections) that are scattered around the city.</p>
<p>Next, we want to calculate how many of those points are inside each postal code area visible on the map. For doing this, we are going to take advantage of spatial index.</p>
<ul class="simple">
<li><p>Building a spatial index for GeoDataFrame is easy in Geopandas. We can extract that by calling an attribute <code class="docutils literal notranslate"><span class="pre">.sindex</span></code>.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Let&#39;s build spatial index for intersection points</span>
<span class="n">intersection_sindex</span> <span class="o">=</span> <span class="n">intersections</span><span class="o">.</span><span class="n">sindex</span>

<span class="c1"># Let&#39;s see what it is</span>
<span class="n">intersection_sindex</span>
</pre></div>
</div>
</div>
</div>
<p>Okay, as we can see the variable contains a <code class="docutils literal notranslate"><span class="pre">SpatialIndex</span></code> object. Fundamentally, this object contains now the geometries in an R-tree data structure as introduced in the beginning of this page.</p>
<p>From this spatial index, we can e.g. see, how the geometries have been grouped in the spatial index.</p>
<ul class="simple">
<li><p>Let’s see how many groups we have, and extract some basic information from them. We can extract this information using <code class="docutils literal notranslate"><span class="pre">.leaves()</span></code> function.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># How many groups do we have?</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of groups:&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">intersection_sindex</span><span class="o">.</span><span class="n">leaves</span><span class="p">()),</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># Print some basic info for few of them</span>
<span class="n">n_iterations</span> <span class="o">=</span> <span class="mi">10</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">group</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">intersection_sindex</span><span class="o">.</span><span class="n">leaves</span><span class="p">()):</span>
    <span class="n">group_idx</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">bbox</span> <span class="o">=</span> <span class="n">group</span>
    <span class="nb">print</span><span class="p">(</span>
        <span class="s2">&quot;Group&quot;</span><span class="p">,</span> <span class="n">group_idx</span><span class="p">,</span> <span class="s2">&quot;contains &quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">),</span> <span class="s2">&quot;geometries, bounding box:&quot;</span><span class="p">,</span> <span class="n">bbox</span>
    <span class="p">)</span>
    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">n_iterations</span><span class="p">:</span>
        <span class="k">break</span>
</pre></div>
</div>
</div>
</div>
<p>We seem to have 908 groups formed in the R-tree, and as we can see, each group seem to consist of 70 geometries. Okay, now as we understand a bit what the <code class="docutils literal notranslate"><span class="pre">R-tree</span></code> index is like. Let’s take that into action.</p>
<p>For conducting fast spatial queries, we can utilize the spatial index of the intersections, and compare the geometry of a given postal code area to the <strong>bounding boxes</strong> of points inside the R-tree spatial index. Let’s start with a single postal code area, to keep things simple.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Select a postal code area representing the city center of Helsinki</span>
<span class="n">city_center_zip_area</span> <span class="o">=</span> <span class="n">postcode_areas</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">postcode_areas</span><span class="p">[</span><span class="s2">&quot;posti_alue&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;00100&quot;</span><span class="p">]</span>
<span class="n">city_center_zip_area</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>Okay, now we can make a spatial query in which we want to select all the points, that are inside this Polygon. We conduct the point in polygon query in two steps:</p>
<ul class="simple">
<li><p><strong>first</strong>, we compare the bounds of the Polygon into the spatial index of the Points. This gives us point <strong>candidates</strong> that are likely to be within the Polygon (at this stage based on the MBR of the points that is stored inside the R-tree).</p></li>
<li><p><strong>secondly</strong>, we go through the candidate points and make a normal spatial intersection query that gives us the accurate results:</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Get the bounding box coordinates of the Polygon as a list</span>
<span class="n">bounds</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">city_center_zip_area</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="c1"># Get the indices of the Points that are likely to be inside the bounding box of the given Polygon</span>
<span class="n">point_candidate_idx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">intersection_sindex</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">bounds</span><span class="p">))</span>
<span class="n">point_candidates</span> <span class="o">=</span> <span class="n">intersections</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">point_candidate_idx</span><span class="p">]</span>

<span class="c1"># Let&#39;s see what we have now</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">city_center_zip_area</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">point_candidates</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Aha, as we can see, now we have successfully selected such points from the dataset that intersect with the <strong>bounding box</strong> of the Polygon. I.e. we conducted the first step of the process.</p>
<p>Next, let’s do the final selection using a “normal” intersect query, which is however, much faster because there is no need to go through all 63.5 thousand points in the full dataset:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Make the precise Point in Polygon query</span>
<span class="n">final_selection</span> <span class="o">=</span> <span class="n">point_candidates</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
    <span class="n">point_candidates</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">city_center_zip_area</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="p">]</span>

<span class="c1"># Let&#39;s see what we have now</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">city_center_zip_area</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">final_selection</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<section id="putting-pieces-together-performance-comparisons">
<h3>Putting pieces together - Performance comparisons<a class="headerlink" href="#putting-pieces-together-performance-comparisons" title="Permalink to this headline">#</a></h3>
<p>Following functions both conduct the spatial query that we saw previously, the first one <strong>without</strong> utilizing spatial index and the second one <strong>with</strong> spatial index. We can use them and compare the performance, so that we can get an idea how much the spatial index affects the performance time-wise.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">intersect_using_spatial_index</span><span class="p">(</span><span class="n">source_gdf</span><span class="p">,</span> <span class="n">intersecting_gdf</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Conduct spatial intersection using spatial index for candidates GeoDataFrame to make queries faster.</span>
<span class="sd">    Note, with this function, you can have multiple Polygons in the &#39;intersecting_gdf&#39; and it will return all the points</span>
<span class="sd">    intersect with ANY of those geometries.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">source_sindex</span> <span class="o">=</span> <span class="n">source_gdf</span><span class="o">.</span><span class="n">sindex</span>
    <span class="n">possible_matches_index</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># &#39;itertuples()&#39; function is a faster version of &#39;iterrows()&#39;</span>
    <span class="k">for</span> <span class="n">other</span> <span class="ow">in</span> <span class="n">intersecting_gdf</span><span class="o">.</span><span class="n">itertuples</span><span class="p">():</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">bounds</span>
        <span class="n">c</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">source_sindex</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">bounds</span><span class="p">))</span>
        <span class="n">possible_matches_index</span> <span class="o">+=</span> <span class="n">c</span>

    <span class="c1"># Get unique candidates</span>
    <span class="n">unique_candidate_matches</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">possible_matches_index</span><span class="p">))</span>
    <span class="n">possible_matches</span> <span class="o">=</span> <span class="n">source_gdf</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">unique_candidate_matches</span><span class="p">]</span>

    <span class="c1"># Conduct the actual intersect</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">possible_matches</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
        <span class="n">possible_matches</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">intersecting_gdf</span><span class="o">.</span><span class="n">unary_union</span><span class="p">)</span>
    <span class="p">]</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">normal_intersect</span><span class="p">(</span><span class="n">source_gdf</span><span class="p">,</span> <span class="n">intersecting_gdf</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Conduct spatial intersection without spatial index.</span>
<span class="sd">    Note, with this function, you can have multiple Polygons in the &#39;intersecting_gdf&#39; and it will return all the points</span>
<span class="sd">    intersect with ANY of those geometries.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">matches</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># &#39;itertuples()&#39; function is a faster version of &#39;iterrows()&#39;</span>
    <span class="k">for</span> <span class="n">other</span> <span class="ow">in</span> <span class="n">intersecting_gdf</span><span class="o">.</span><span class="n">itertuples</span><span class="p">():</span>
        <span class="n">c</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">source_gdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">source_gdf</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">geometry</span><span class="p">)]</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
        <span class="n">matches</span> <span class="o">+=</span> <span class="n">c</span>

    <span class="c1"># Get all points that are intersecting with the Polygons</span>
    <span class="n">unique_matches</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">matches</span><span class="p">))</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">source_gdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">source_gdf</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">unique_matches</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">result</span>
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Let’s compare their performance and time it. Here we utilize a special IPython magic function called <code class="docutils literal notranslate"><span class="pre">%timeit</span></code> that allows to test how long it takes to run a specific function (it actually runs the function multiple times to get a more representative timing).</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Test the spatial query with spatial index</span>
<span class="o">%</span><span class="k">timeit</span> intersect_using_spatial_index(source_gdf=intersections, intersecting_gdf=city_center_zip_area)
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Test the spatial query without spatial index</span>
<span class="o">%</span><span class="k">timeit</span> normal_intersect(source_gdf=intersections, intersecting_gdf=city_center_zip_area)
</pre></div>
</div>
</div>
</div>
<p>Okay, as these tests demonstrate, using the spatial index gives a significant boost in the performance, by being around 17x faster.</p>
<p>Making the spatial query only with a single Polygon (as in the example) might not make a big difference, but having hundreds or thousands of Polygons, and wanting to find all points that are inside those ones, start to make a drastic difference.</p>
</section>
<section id="counting-the-intersections">
<h3>Counting the intersections<a class="headerlink" href="#counting-the-intersections" title="Permalink to this headline">#</a></h3>
<p>The ultimate goal of this tutorial was to count the intersections per postal code. We can do that easily and fast with Geopandas, by conducting a <code class="docutils literal notranslate"><span class="pre">spatial</span> <span class="pre">join</span></code> between the two datasets. Spatial join in Geopandas is highly performant, and in fact, it utilizes spatial index to make the queries fast. The following parts might include a bit advanced tricks that we have not covered, but for the sake of completeness, the following steps count the intersections per postal code area. Finally, we plot a density of the intersections as a number of intersections per square kilometer (per postal code area).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Count intersections by postal code area</span>
<span class="n">intersection_cnt</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">gpd</span><span class="o">.</span><span class="n">sjoin</span><span class="p">(</span><span class="n">postcode_areas</span><span class="p">,</span> <span class="n">intersections</span><span class="p">)</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;posti_alue&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">size</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
<span class="p">)</span>
<span class="n">intersection_cnt</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Merge with postcode data and plot</span>
<span class="n">intersection_cnt</span> <span class="o">=</span> <span class="n">intersection_cnt</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="s2">&quot;intersection_cnt&quot;</span><span class="p">})</span>
<span class="n">postcode_areas</span> <span class="o">=</span> <span class="n">postcode_areas</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">intersection_cnt</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s2">&quot;posti_alue&quot;</span><span class="p">)</span>
<span class="n">postcode_areas</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Plot intersection density (number of intersections per square kilometer inside a Postal code)</span>
<span class="n">m2_to_km2_converter</span> <span class="o">=</span> <span class="mi">1000000</span>
<span class="n">postcode_areas</span><span class="p">[</span><span class="s2">&quot;intersection_density&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">postcode_areas</span><span class="p">[</span><span class="s2">&quot;intersection_cnt&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span>
    <span class="n">postcode_areas</span><span class="o">.</span><span class="n">area</span> <span class="o">/</span> <span class="n">m2_to_km2_converter</span>
<span class="p">)</span>
<span class="n">postcode_areas</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="s2">&quot;intersection_density&quot;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s2">&quot;RdYlBu_r&quot;</span><span class="p">,</span> <span class="n">legend</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>From the map, we can see that the intersection density is clearly highest in the city center areas of Helsinki (red colored areas).</p>
</section>
<section id="note">
<h3>Note<a class="headerlink" href="#note" title="Permalink to this headline">#</a></h3>
<p>As we have learned from this tutorial, spatial index can make the spatial queries significantly faster. There is however, a specific situation in which spatial index does not provide any improvements for the performance: if your polygon and points have more or less similar spatial extent (bounding box), the spatial index does not help to make the queries faster due to its design in working on a level of bounding boxes. This happens e.g. in following case:</p>
<p><img alt="los-angeles-boundary-intersections.png" src="../../../_images/los-angeles-boundary-intersections.png" />
<em>Example of a situation where spatial index does not provide boost in performance</em> (Source: <a class="reference external" href="https://geoffboeing.com/2016/10/r-tree-spatial-index-python/">G. Boeing, 2016</a>)</p>
<p>As we can see, in the map, there is a complex Polygon that share more or less identical extent as the point layer, which is problematic from performance point of view.</p>
<p>There is, however, a nice strategy to deal with this kind of situation, by sub-dividing the Polygon into smaller subsets (having also smaller bounding boxes) that will enable the spatial index to boost the queries:</p>
<p><img alt="los-angeles-boundary-quadrats-intersections" src="../../../_images/los-angeles-boundary-quadrats-intersections.png" />.</p>
<p>You can read more about this strategy from an excellent post from <a class="reference external" href="https://geoffboeing.com/2016/10/r-tree-spatial-index-python/">G. Boeing</a>.</p>
</section>
</section>
</section>


              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
    <a class='left-prev' id="prev-link" href="03-geometric-manipulation.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title">Geometric data manipulations</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="../../chapter-07/index.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Raster data processing</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By Henrikki Tenkanen, Vuokko Heikinheimo, David Whipp<br/>
  
      &copy; Copyright 2020-2022, Henrikki Tenkanen, Vuokko Heikinheimo, David Whipp.<br/>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>