
<!DOCTYPE html>


<html lang="en" data-content_root="../../../" data-theme="light">

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Nearest neighbour analysis</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "light";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../../../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=8f2a1f02" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/sphinx-book-theme.css?v=eba8b062" />
    <link rel="stylesheet" type="text/css" href="../../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="../../../_static/css/custom-toggle-button.css?v=14db4526" />
    <link rel="stylesheet" type="text/css" href="../../../_static/css/custom-text-formatting.css?v=4ef71e6f" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../../../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../../../_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script src="../../../_static/design-tabs.js?v=f930bc37"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="../../../_static/sphinx-thebe.js?v=c100c467"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'part2/chapter-06/md/07-nearest-neighbour';</script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="light">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../../../index.html">
  
  
  
  
  
    
    
    
    <img src="../../../_static/pythongis-logo.png" class="logo__image only-light" alt=" - Home"/>
    <script>document.write(`<img src="../../../_static/pythongis-logo.png" class="logo__image only-dark" alt=" - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Part I - Python essentials</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../../part1/index.html">Overview and learning goals</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../part1/chapter-01/index.html">1. Getting started</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-01/nb/0-learning-objectives.html">Learning objectives</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-01/nb/00-motivation.html">1.1 Motivation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-01/nb/01-computers-and-programs.html">1.2 Computers and programs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-01/nb/02-why-python.html">1.3 Why Python?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-01/nb/03-writing-and-running-python-code.html">1.4 Writing and running Python code</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-01/nb/04-using-jupyterlab.html">1.5 Using JupyterLab for writing code</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-01/nb/05-quick-start.html">1.6 Quickly getting started (without installing Python)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-01/nb/06-installation.html">1.7 Installing Python and adding libraries</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../part1/chapter-02/index.html">2. Basic programming concepts</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-02/nb/0-learning-objectives.html">Learning objectives</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-02/nb/00-python-basics.html">2.1 Getting started with Python</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-02/nb/01-lists-and-indices.html">2.2 Lists and indices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-02/nb/02-text-and-numbers.html">2.3 Working with text and numbers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-02/nb/03-for-loops.html">2.4 for loops</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-02/nb/04-conditional-statements.html">2.5 Conditional statements</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-02/nb/05-functions.html">2.6 Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-02/nb/06-writing-scripts.html">2.7 Writing script files</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-02/nb/07-modules.html">2.8 Loading and using modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-02/nb/08-exercises.html">Exercises</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../part1/chapter-03/index.html">3. Introduction to data analysis</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-03/nb/0-learning-objectives.html">Learning objectives</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-03/nb/00-pandas-basics.html">3.1 Getting started with data analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-03/nb/01-data-manipulation.html">3.2 Common tabular operations in pandas</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-03/nb/02-data-analysis.html">3.3 Data wrangling, grouping and aggregation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-03/nb/03-temporal-data.html">3.4 Working with temporal data</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-03/nb/04-exercises.html">Exercises</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../part1/chapter-04/index.html">4. Introduction to data visualization</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-04/nb/0-learning-objectives.html">Learning objectives</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-04/nb/00-plotting-in-python.html">4.1 Plotting in Python</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-04/nb/01-basic-plotting.html">4.2 Plotting with pandas and matplotlib</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-04/nb/02-subplots.html">4.3 Creating subplots</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-04/nb/03-plot-formatting.html">4.4 Effective plot design: line plots</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-04/nb/04-exercises.html">Exercises</a></li>
</ul>
</details></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Part II - Introduction to GIS with Python</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../index.html">Overview and learning goals</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../chapter-05/index.html">5. Getting started</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../chapter-05/nb/0-learning-objectives.html">Learning objectives</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter-05/nb/00-motivation-to-use-python-for-gis.html">5.1 Motivation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter-05/nb/01-introduction-to-geographic-data-in-python.html">5.2 Geographic data in Python</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter-05/nb/02-introduction-to-coordinate-reference-systems.html">5.3 Coordinate reference systems</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../index.html">6. Vector data processing</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../nb/0-learning-objectives.html">Learning objectives</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nb/00-introduction-to-geographic-objects.html">6.1 Representing geographic data in vector format</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nb/01-geodataframe.html">6.2 Introduction to geopandas GeoDataFrames</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nb/02-geometric-operations.html">6.3 Common geometric operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nb/03-coordinate-reference-system.html">6.4 Working with map projections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nb/04-geocoding.html">6.5 Geocoding</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nb/05-spatial-queries.html">6.6 Selecting data based on spatial relationships</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nb/06-spatial-join.html">6.7 Spatial join</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nb/07-nearest-neighbour.html">6.8 Nearest neighbour analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nb/08-overlay-analysis-with-vector-data.html">6.9 Vector overlay operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nb/09-exercises.html">Exercises</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../chapter-07/index.html">7. Raster data processing</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../chapter-07/nb/0-learning-objectives.html">Learning objectives</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter-07/nb/00-introduction-to-raster-data.html">7.1 Representing geographic data in raster format</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter-07/nb/01-data-structures-xarray.html">7.2 Introduction to data structures in xarray</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter-07/nb/02-common-raster-operations.html">7.3 Common raster operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter-07/nb/03-coordinate-reference-systems-raster.html">7.4 Coordinate reference system management</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter-07/nb/04-map-algebra.html">7.5 Map algebra</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter-07/nb/05-data-cubes.html">7.6 Working with data cubes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter-07/nb/06-exercises.html">Exercises</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../chapter-08/index.html">8. Geographic data visualization</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../chapter-08/nb/0-learning-objectives.html">Learning objectives</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter-08/nb/00-introduction-to-geographic-visualization.html">8.1 Introduction to geographic visualization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter-08/nb/01-static-vector-maps.html">8.2 Static maps</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter-08/nb/02-static-raster-maps.html">8.3 Visualizing raster layers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter-08/nb/03-interactive-maps.html">8.4 Interactive maps</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter-08/nb/04-map-design-principles-and-colors.html">8.5 Designing maps</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter-08/nb/05-exercises.html">Exercises</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../chapter-09/index.html">9. Using online geographic data sources</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../chapter-09/nb/0-learning-objectives.html">Learning objectives</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter-09/nb/00-retrieving-osm-data.html">9.1 Retrieving OpenStreetMap data</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter-09/nb/01-retrieving-data-from-wfs.html">9.2 Retrieving data from Web Feature Service (WFS)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter-09/nb/02-retrieving-data-from-wcs.html">9.3 Retrieving data from Web Coverage Service (WCS)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter-09/nb/03-read-data-from-spatial-databases.html">9.4 Reading data from spatial databases</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter-09/nb/04-exercises.html">Exercises</a></li>
</ul>
</details></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Part III - Case studies</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../part3/chapter-10/index.html">10. Spatial interpolation</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../part3/chapter-10/nb/00-introduction-to-spatial-interpolation.html">Introduction to spatial interpolation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part3/chapter-10/nb/01-inverse-distance-weighting.html">Inverse Distance Weighting interpolation with Python</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part3/chapter-10/nb/02-exercises.html">Exercises</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../part3/chapter-11/index.html">11. Spatial network analysis</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../part3/chapter-11/nb/00-introduction-to-spatial-network-analysis.html">Introduction to spatial network analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part3/chapter-11/nb/02-multimodal-spatial-accessibility-modelling.html">Multimodal spatial accessibility analysis with Python</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part3/chapter-11/nb/03-exercises.html">Exercises</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../part3/chapter-12/index.html">12. Watershed analysis</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../part3/chapter-12/nb/00-watershed-analysis-with-pysheds.html">Watershed analysis with pysheds</a></li>
</ul>
</details></li>
<li class="toctree-l1"><a class="reference internal" href="../../../part3/chapter-13/index.html">13. Conclusions</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Appendices</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../back-matter/appendix-a.html">A. Working effectively in Python</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../back-matter/nb/appendix-0-python-environments.html">A.1 Tips for maintaining Python environments</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../back-matter/nb/appendix-1-best-practices.html">A.2 Python programming best practices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../back-matter/nb/appendix-2-git-github.html">A.3 Version control with using Git and GitHub</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../back-matter/nb/appendix-3-script-files.html">A.4 Using Python script files</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../back-matter/nb/appendix-4-testing-and-debugging.html">A.5 Testing and debugging your code</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../back-matter/appendix-b.html">B. Solutions to questions and exercises</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../back-matter/nb/appendix-5-question-solutions.html">B.1 Question solutions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../back-matter/nb/appendix-6-exercise-solutions.html">B.2 Exercise solutions</a></li>
</ul>
</details></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Back matter</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../../back-matter/nb/acknowledgements.html">Acknowledgements</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../back-matter/nb/glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../back-matter/nb/references.html">References</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../authors.html">About the authors</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Datasets</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../../data/index.html">Data overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../data/noaa-data.html">NOAA Weather data</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">


<a href="https://github.com/Python-GIS-book/site/edit/main/source/part2/chapter-06/md/07-nearest-neighbour.md" target="_blank"
   class="btn btn-sm btn-source-edit-button"
   title="Suggest edit"
   data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-pencil-alt"></i>
  </span>

</a>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../../../_sources/part2/chapter-06/md/07-nearest-neighbour.md" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.md</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Nearest neighbour analysis</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#nearest-neighbour-analysis-in-python">Nearest neighbour analysis in Python</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#nearest-neighbors-with-polygon-and-linestring-data">Nearest neighbors with Polygon and LineString data</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#question-6-11">Question 6.11</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#k-nearest-neighbor-search">K-Nearest Neighbor search</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#nearest-neighbors-within-radius">Nearest neighbors within radius</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#question-6-12">Question 6.12</a></li>
</ul>
</li>
</ul>
</li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <!-- #region editable=true slideshow={"slide_type": ""} -->
<section class="tex2jax_ignore mathjax_ignore" id="nearest-neighbour-analysis">
<h1>Nearest neighbour analysis<a class="headerlink" href="#nearest-neighbour-analysis" title="Link to this heading">#</a></h1>
<!-- #endregion -->
<!-- #region editable=true slideshow={"slide_type": ""} -->
<p>The idea of neighbourhood is one of the fundamental concepts in geographic data analysis and modelling. Being able to understand how close geographic objects are to each other, or which features are neighboring a specific location is fundamental to various spatial analysis techniques, such as spatial interpolation (which we cover in Chapter 10) or understanding whether there is spatial autocorrelation (i.e. clustering) in the data (see Chapters <a class="reference external" href="https://geographicdata.science/book/notebooks/06_spatial_autocorrelation.html">6</a> and <a class="reference external" href="https://geographicdata.science/book/notebooks/07_local_autocorrelation.html">7</a> in <span id="id1"><a class="reference internal" href="../../../back-matter/nb/references.html#id18" title="Sergio Rey, Dani Arribas-Bel, and Levi John Wolf. Geographic Data Science with Python. Chapman and Hall/CRC, 1st edition, 2023. ISBN 978-0-429-29250-7. URL: https://geographicdata.science/book/intro.html, doi:10.1201/9780429292507.">Rey <em>et al.</em>, 2023</a></span>). Many of these techniques rely on the idea that proximity in geographic space typically indicates also similarity in attribute space. For example, it is quite typical that a neighborhood with high population density is next to another neighborhood that also has high concentration of residents (i.e. population density tends to cluster). One of the most famous notions related to this is the <em>First law of geography</em> which states that “everything is related to everything, but near things are more related than distant things” (<span id="id2"><a class="reference internal" href="../../../back-matter/nb/references.html#id23" title="Waldo R. Tobler. A Computer Movie Simulating Urban Growth in the Detroit Region. Economic Geography, 46:234-240, 1970.">Tobler, 1970</a></span>). Thus, being able to understand how close neighboring geographic features are, or which objects are the closest ones to specific location is an important task in GIS.</p>
<p>Figure 6.45 illustrates two common ways to find nearest neighbors to specific locations. In these examples, we have two Point datasets visualized with blue circles and red rectangles that are used for doing the nearest neighbor analysis. In the first example (top row), the idea is to find the closest geometry (rectangles) for all the points in the area. Here, the nearest neighbor is determined based on distance between the points and rectangles, and the nearest neighbors are visualized with a line from every point to the closest rectangle (on the right). The bottom row shows an example in which we aim to find the closest point for each rectangle, but in this case we also apply a maximum search distance that limits the search area. Only those points that are within the search area are considered when finding the nearest neighbor, while the points outside of this area are simply ignored. As a result, the point closest to a given rectangle is visualized with a connected line (on the right). In these examples, the geographic objects are simple point like features, but similar approach can be used with any geographic features, for example by finding closest LineString or Polygon geometry to a given Point, or by finding the closest Polygon to another Polygon. In these cases, the calculations are a bit more complicated, but the basic idea is the same.</p>
<!-- #endregion -->
<!-- #region editable=true slideshow={"slide_type": ""} -->
<p><img alt="Figure 6.46. The basic idea of finding a nearest neighbour based on geographic distance." src="../../../_images/nearest-neighbour.png" /></p>
<p><em><strong>Figure 6.46</strong>. The basic idea of finding a nearest neighbour based on geographic distance.</em></p>
<!-- #endregion -->
<!-- #region editable=true slideshow={"slide_type": ""} -->
<p>Quite often with very large datasets, we might want to limit the search area up to a specific maximum distance. This can be due to practical reasons as it can significantly speed up the computation time, or because we have specific reasoning that makes it sensible to limit the search area. For example, if we would aim to understand how easily accessible public transportation is to citizens living in a city, it would make sense to limit the search area e.g. up to 2 km from the homes of people, because people are not willing to walk for very long distances to reach a bus stop. It’s important to notice that the distances in the calculations are commonly based on the Euclidean distance, i.e. we calculate the distances based on coordinates on a Cartesian plain, meaning that the distances do not consider changes in height (i.e. third dimension is omitted). It is of course possible also to consider 3D distances, but the most typical Python tools ignore the height information.</p>
<!-- #endregion -->
<section id="nearest-neighbour-analysis-in-python">
<h2>Nearest neighbour analysis in Python<a class="headerlink" href="#nearest-neighbour-analysis-in-python" title="Link to this heading">#</a></h2>
<p>In Python, there are various libraries that can be used to find nearest neighbors for given set of geometries, including <code class="docutils literal notranslate"><span class="pre">geopandas</span></code>, <code class="docutils literal notranslate"><span class="pre">shapely</span></code>, <code class="docutils literal notranslate"><span class="pre">scipy</span></code>, <code class="docutils literal notranslate"><span class="pre">scikit-learn</span></code>, and <code class="docutils literal notranslate"><span class="pre">pysal</span></code> among others. Here, we first introduce how <code class="docutils literal notranslate"><span class="pre">geopandas</span></code> can be used to find the nearest neighbors for all Point geometries in a given <code class="docutils literal notranslate"><span class="pre">GeoDataFrame</span></code> based on <code class="docutils literal notranslate"><span class="pre">Point</span></code>objects from another <code class="docutils literal notranslate"><span class="pre">GeoDataFrame</span></code>. Then we show how to find nearest neighbor between two Polygon datasets, and finally we show how to use <code class="docutils literal notranslate"><span class="pre">scipy</span></code> library to find K-Nearest Neighbors (KNN) with Point data.</p>
<p>In the following, we go through a very practical example that relates to our daily commute: Where is the closest public transport stop from my place of residence? Hence, our aim is to search for each building point in the Helsinki Region the closest public transport stop. In <code class="docutils literal notranslate"><span class="pre">geopandas</span></code>, we can find nearest neighbors for all geometries in a given <code class="docutils literal notranslate"><span class="pre">GeoDataFrame</span></code> using the <code class="docutils literal notranslate"><span class="pre">.sjoin_nearest()</span></code> method. To test it out, let’s start by reading two datasets representing buildings and stops and visualize them to understand a bit better what we have:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">geopandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">gpd</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>

<span class="n">stops</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="s2">&quot;data/Helsinki/pt_stops_helsinki.gpkg&quot;</span><span class="p">)</span>
<span class="n">building_points</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="s2">&quot;data/Helsinki/building_points_helsinki.zip&quot;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of stops:&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">stops</span><span class="p">))</span>
<span class="n">stops</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of buildings:&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">building_points</span><span class="p">))</span>
<span class="n">building_points</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<!-- #region editable=true slideshow={"slide_type": ""} -->
<p>As we can see, both <code class="docutils literal notranslate"><span class="pre">GeoDataFrames</span></code> contain <code class="docutils literal notranslate"><span class="pre">Point</span></code> geometries. There seems to be approximately 8400 stops and almost 159 thousand buildings. Hence, we have already a fair amount of data and calculations to do, to find the nearest neighbor for each building. Let’s still visualize these data side-by-side:</p>
<!-- #endregion -->
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">nrows</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ncols</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>

<span class="c1"># Plot buildings</span>
<span class="n">building_points</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax1</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Buildings&quot;</span><span class="p">)</span>

<span class="c1"># Plot stops</span>
<span class="n">stops</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax2</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">)</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Stops&quot;</span><span class="p">);</span>
</pre></div>
</div>
<!-- #region editable=true slideshow={"slide_type": ""} -->
<p><em><strong>Figure 6.47</strong>. Maps representing the buildings and public transport stops which we use to find the closest stop for each building.</em></p>
<p>As mentioned earlier, finding the nearest geometries between two <code class="docutils literal notranslate"><span class="pre">GeoDataFrames</span></code> (here building and stop points) can be done easily using the <code class="docutils literal notranslate"><span class="pre">.sjoin_nearest()</span></code> method in <code class="docutils literal notranslate"><span class="pre">geopandas</span></code>. As the name implies, this method is actually designed to merge data between <code class="docutils literal notranslate"><span class="pre">GeoDataFrames</span></code> in a similar manner as with regular <code class="docutils literal notranslate"><span class="pre">.sjoin()</span></code> method. However, in this case the method is actually searching for the closest geometries instead of relying on spatial predicates, such as <em>within</em>. The <code class="docutils literal notranslate"><span class="pre">sjoin_nearest()</span></code> can be used for different geometry types, so the input geometries do not necessarily need to be Point objects as in our example. Under the hood, the method uses a <em><a class="reference internal" href="../../../back-matter/nb/glossary.html#term-Spatial-index"><span class="xref std std-term">spatial index</span></a></em> called <code class="docutils literal notranslate"><span class="pre">STRTree</span></code> (<span id="id3"><a class="reference internal" href="../../../back-matter/nb/references.html#id13" title="Scott T. Leutenegger, Mario A. Lopez, and Jeffrey Edgington. Str: a simple and efficient algorithm for r-tree packing. In Proceedings 13th International Conference on Data Engineering, 497-506. IEEE Comput. Soc. Press, 1997. URL: http://ieeexplore.ieee.org/document/582015, doi:10.1109/ICDE.1997.582015.">Leutenegger <em>et al.</em>, 1997</a></span>) which is an efficient implementation of the <em><a class="reference internal" href="../../../back-matter/nb/glossary.html#term-R-tree"><span class="xref std std-term">R-tree</span></a></em> dynamic index structure for spatial searching (<span id="id4"><a class="reference internal" href="../../../back-matter/nb/references.html#id7" title="Antonin Guttman. R-Trees - A Dynamic Index Structure for Spatial Searching. In Proceedings of the 1984 ACM SIGMOD International Conference on Management of data – SIGMOD, volume 14, 47-57. Association for Computing Machinery, 1984. doi:doi:10.1145/602259.602266.">Guttman, 1984</a></span>). The STRTree is implemented in the <code class="docutils literal notranslate"><span class="pre">shapely</span></code> library (used by <code class="docutils literal notranslate"><span class="pre">geopandas</span></code>) and the technique makes the nearest neighbor queries very efficient. You can read more about spatial indices in Appendices section of the book. For the method to work properly, it is recommended to ensure that the both <code class="docutils literal notranslate"><span class="pre">GeoDataFrames</span></code> are having the same coordinate reference system (CRS), and preferably having a projected (metric) CRS because that ensures that the reported distances are meaningful (in meters) and correct. Hence, let’s start by reprojecting our latitude and longitude values into a metric system using the national EUREF-FIN coordinate reference system (EPSG code 3067) for Finland:</p>
<!-- #endregion -->
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">stops</span> <span class="o">=</span> <span class="n">stops</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">epsg</span><span class="o">=</span><span class="mi">3067</span><span class="p">)</span>
<span class="n">building_points</span> <span class="o">=</span> <span class="n">building_points</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">epsg</span><span class="o">=</span><span class="mi">3067</span><span class="p">)</span>

<span class="n">stops</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<!-- #region editable=true slideshow={"slide_type": ""} -->
<p>Now the <code class="docutils literal notranslate"><span class="pre">GeoDataFrames</span></code> are surely in the same coordinate system and we can see that the coordinates in the <code class="docutils literal notranslate"><span class="pre">geometry</span></code> column have changed representing meters. Next, we will use the <code class="docutils literal notranslate"><span class="pre">buildings.sjoin_nearest()</span></code> to find the closest stop for each building. Because we are interested to find the closest stop geometry for each building, the <code class="docutils literal notranslate"><span class="pre">buildings</span></code> <code class="docutils literal notranslate"><span class="pre">GeoDataFrame</span></code> is on the left hand side of the command. As inputs, we pass the <code class="docutils literal notranslate"><span class="pre">stops</span></code> <code class="docutils literal notranslate"><span class="pre">GeoDataFrame</span></code> as well as give a name for a column which is used to store information about the distance between a given building and the closest stop (this is optional):</p>
<!-- #endregion -->
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="n">time</span>
<span class="n">closest</span> <span class="o">=</span> <span class="n">building_points</span><span class="o">.</span><span class="n">sjoin_nearest</span><span class="p">(</span><span class="n">stops</span><span class="p">,</span> <span class="n">distance_col</span><span class="o">=</span><span class="s2">&quot;distance&quot;</span><span class="p">)</span>
<span class="n">closest</span>
</pre></div>
</div>
<!-- #region editable=true slideshow={"slide_type": ""} -->
<p>As a result, we now have found the closest stop for each building including the attributes of the closest stops that were merged into the results. The last column in the table shows the distance in meters between a given building and the closest stop. The distance is only returned upon request as we did by specifying <code class="docutils literal notranslate"><span class="pre">distance_col=&quot;distance&quot;</span></code>. The column <code class="docutils literal notranslate"><span class="pre">index_right</span></code> provides information about the index number of the closest stop in the <code class="docutils literal notranslate"><span class="pre">stops</span></code> <code class="docutils literal notranslate"><span class="pre">GeoDataFrame</span></code>. If you look carefully, you can see that the number of rows in our result has actually increased slightly from the original (158731 vs 159818). This happens because for some geometries in the <code class="docutils literal notranslate"><span class="pre">buildings</span></code> <code class="docutils literal notranslate"><span class="pre">GeoDataFrame</span></code>, the distance between the building and two (or more) stops have been exactly the same (i.e. they are equidistant). In such cases, the <code class="docutils literal notranslate"><span class="pre">sjoin_nearest()</span></code> will store both records into the results by duplicating the building information and attaching information from the stops into separate rows accordingly. In some cases, this can cause trouble for further analysis, so it is good to be careful and investigate whether any duplicate buildings have appeared into the results. If this is the case, and if the duplicates cause issues in your analysis, you might need to pick one of them for further analysis based on some criteria. A simple way is to pick the first (or last) duplicate if you do not have any specific justification for making the selection.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">%time</span></code> command at the beginning of the cell provides us some details about the time it took to find the nearest neighbors and merge the data between the two data sets. As we can see, the computations are very efficient taking only a matter of some microseconds for almost 159 thousand observations. We can make this even faster by specifying a <code class="docutils literal notranslate"><span class="pre">max_distance</span></code> parameter that specifies the maximum search distance. Here, we specify the maximum distance as 100 meters from each building:</p>
<!-- #endregion -->
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="n">time</span>
<span class="n">closest_limited</span> <span class="o">=</span> <span class="n">building_points</span><span class="o">.</span><span class="n">sjoin_nearest</span><span class="p">(</span>
    <span class="n">stops</span><span class="p">,</span> <span class="n">max_distance</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">distance_col</span><span class="o">=</span><span class="s2">&quot;distance&quot;</span>
<span class="p">)</span>
<span class="n">closest_limited</span>
</pre></div>
</div>
<!-- #region editable=true slideshow={"slide_type": ""} -->
<p>As we can see, there was a slight improvement in the execution time compared to the previous call without specifying the <code class="docutils literal notranslate"><span class="pre">max_distance</span></code> parameter. The difference can be more significant if you have larger datasets or more complicated geometries (e.g. Polygons). One important aspect to notice from these results is that the number of rows has decreased significantly: from 160 to 40 thousand buildings. This happens because our search distance was very low (100 meters), and as a consequence, there were many buildings that did not have any stops within 100 meter radius from them. Because the default join type in <code class="docutils literal notranslate"><span class="pre">sjoin_nearest</span></code> is <code class="docutils literal notranslate"><span class="pre">inner</span></code> join, all the records that did not have a stop within 100 meters were dropped. If you would like to keep all the records in the results, to e.g. investigate which buildings do not have any stops within the search radius, you can add parameter <code class="docutils literal notranslate"><span class="pre">how=&quot;left&quot;</span></code>, which will retain all buildings from the original <code class="docutils literal notranslate"><span class="pre">GeoDataFrame</span></code>.</p>
<p>In some cases, you might actually want to connect the nearest neighbors to each other with a straight line. For doing this, we need to merge also the Point geometries from the other layer into our results, which can then be used to create a LineString connecting the points to each other. This can be useful for many purposes, but in our case, we want to do this to be able to validate whether our results are correct. For merging the closest stop geometries into our results, we can take advantage of the <code class="docutils literal notranslate"><span class="pre">index_right</span></code> column in our table and conduct a normal table join using the <code class="docutils literal notranslate"><span class="pre">.merge()</span></code> method. Below, we create a table join between the tables using the <code class="docutils literal notranslate"><span class="pre">.merge()</span></code> and use the <code class="docutils literal notranslate"><span class="pre">&quot;index_right&quot;</span></code> column in the <code class="docutils literal notranslate"><span class="pre">closest</span></code> <code class="docutils literal notranslate"><span class="pre">GeoDataFrame</span></code> as a key on the left table while the index of the <code class="docutils literal notranslate"><span class="pre">stops</span></code> is used as the key on the right table. Notice that we only keep the <code class="docutils literal notranslate"><span class="pre">geometry</span></code> columns from the <code class="docutils literal notranslate"><span class="pre">stops</span></code> <code class="docutils literal notranslate"><span class="pre">GeoDataFrame</span></code> because all the other attributes already exist in our results:</p>
<!-- #endregion -->
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">closest</span> <span class="o">=</span> <span class="n">closest</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
    <span class="n">stops</span><span class="p">[[</span><span class="n">stops</span><span class="o">.</span><span class="n">active_geometry_name</span><span class="p">]],</span> <span class="n">left_on</span><span class="o">=</span><span class="s2">&quot;index_right&quot;</span><span class="p">,</span> <span class="n">right_index</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span>
<span class="n">closest</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
<!-- #region editable=true slideshow={"slide_type": ""} -->
<p>As a result, we now brought a new column into our results, namely the <code class="docutils literal notranslate"><span class="pre">geometry_y</span></code>. Because there was a column called <code class="docutils literal notranslate"><span class="pre">geometry</span></code> in both <code class="docutils literal notranslate"><span class="pre">GeoDataFrames</span></code>, <code class="docutils literal notranslate"><span class="pre">geopandas</span></code> automatically renamed the columns into <code class="docutils literal notranslate"><span class="pre">geometry_x</span></code> and <code class="docutils literal notranslate"><span class="pre">geometry_y</span></code> respectively.</p>
<p>Now we have all the data that we need to create a connecting <code class="docutils literal notranslate"><span class="pre">LineString</span></code> between the buildings and the closest stops. We can do this by using the <code class="docutils literal notranslate"><span class="pre">linestrings()</span></code> function of the <code class="docutils literal notranslate"><span class="pre">shapely</span></code> library which is a fast (vectorized) way to create a number of <code class="docutils literal notranslate"><span class="pre">LineString</span></code> objects based on point coordinates (the function only accepts numbers as input, i.e. not <code class="docutils literal notranslate"><span class="pre">Point</span></code> objects). To extract the point coordinates from the <code class="docutils literal notranslate"><span class="pre">Point</span></code> objects stored in the <code class="docutils literal notranslate"><span class="pre">geometry_x</span></code> and <code class="docutils literal notranslate"><span class="pre">geometry_y</span></code> columns, we use the <code class="docutils literal notranslate"><span class="pre">.get_coordinates()</span></code> method of <code class="docutils literal notranslate"><span class="pre">geopandas</span></code> that returns the <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> coordinates as <code class="docutils literal notranslate"><span class="pre">Series</span></code> objects/columns. Then we convert these into <code class="docutils literal notranslate"><span class="pre">numpy</span></code> arrays using the <code class="docutils literal notranslate"><span class="pre">to_numpy()</span></code> method which we pass to the <code class="docutils literal notranslate"><span class="pre">linestrings()</span></code> function. Finally, we store the resulting <code class="docutils literal notranslate"><span class="pre">LineStrings</span></code> into a column <code class="docutils literal notranslate"><span class="pre">geometry</span></code> which we set as the active geometry of the <code class="docutils literal notranslate"><span class="pre">GeoDataFrame</span></code>:</p>
<!-- #endregion -->
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">shapely</span><span class="w"> </span><span class="kn">import</span> <span class="n">linestrings</span>

<span class="n">closest</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">linestrings</span><span class="p">(</span>
    <span class="n">closest</span><span class="o">.</span><span class="n">geometry_x</span><span class="o">.</span><span class="n">get_coordinates</span><span class="p">()</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span>
    <span class="n">closest</span><span class="o">.</span><span class="n">geometry_y</span><span class="o">.</span><span class="n">get_coordinates</span><span class="p">()</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span>
<span class="p">)</span>

<span class="n">closest</span> <span class="o">=</span> <span class="n">closest</span><span class="o">.</span><span class="n">set_geometry</span><span class="p">(</span><span class="s2">&quot;geometry&quot;</span><span class="p">)</span>
<span class="n">closest</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
<!-- #region editable=true slideshow={"slide_type": ""} -->
<p>Great! Now we have created a new geometry column that contains the lines between buildings and the closest stops. To better understand the results, let’s create a nice map that visualizes the buildings, stops and the connecting lines between the buildings and the closest stops in a single figure:</p>
<!-- #endregion -->
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">ax</span> <span class="o">=</span> <span class="n">closest</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">lw</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">building_points</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">stops</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mf">8.5</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;s&quot;</span><span class="p">)</span>
<span class="c1"># Zoom to specific area</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="mi">382000</span><span class="p">,</span> <span class="mi">384100</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="mi">6676000</span><span class="p">,</span> <span class="mi">6678000</span><span class="p">);</span>
</pre></div>
</div>
<!-- #region editable=true slideshow={"slide_type": ""} -->
<p><em><strong>Figure 6.48</strong>. A map showing the buildings (red points), the stops (black rectangles) and the lines between the buildings and the closest stops.</em></p>
<p>As we can see from the Figure 6.48, the nearest neighbor search have worked well as planned, and each building marked with red color has been correctly connected with a line to the closest stop. The map reveals that there are multiple isolated stops that do not have any buildings connected to them. As a practical example, this information could be used e.g. for transport planning by investigating whether these isolated stops are less used by citizens to get on board of the public transport vehicles. This information could again be used by transport planners to decide whether there is a need to maintain these isolated stops. Thus, with these rather simple computations, one can already provide useful information that has relevance in real life. Finally, because we have calculated the distance between buildings and the stops, it is easy to do some descriptive analysis based on this data providing information about levels of access to public transport in the region:</p>
<!-- #endregion -->
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">closest</span><span class="p">[</span><span class="s2">&quot;distance&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">describe</span><span class="p">()</span>
</pre></div>
</div>
<!-- #region editable=true slideshow={"slide_type": ""} -->
<p>As we can see, the average distance to public transport in the region is around 230 meters. More than 75 % of the buildings seem to be within within 3.5 minute walking time (~260 meters with walking speed of 4.5 kmph) which indicates very good situation in terms of accessibility levels in the region overall. There seem to be some really remote buildings in the data as well, as the longest distance to closest public transport stop is more than 7 kilometers.</p>
<!-- #endregion -->
<!-- #region editable=true slideshow={"slide_type": ""} -->
<section id="nearest-neighbors-with-polygon-and-linestring-data">
<h3>Nearest neighbors with Polygon and LineString data<a class="headerlink" href="#nearest-neighbors-with-polygon-and-linestring-data" title="Link to this heading">#</a></h3>
<p>In some cases, you might need to find the closest neighbors for a given set of Polygons or LineStrings. Luckily, the <code class="docutils literal notranslate"><span class="pre">sjoin_nearest()</span></code> method works in a similar manner with all geometry types, i.e. you can find the nearest neighbors using Point, LineString, Polygon, MultiPoint, MultiLineString and MultiPoint geometries as input. Also finding nearest neighbors between different geometry types is supported, meaning that you can for example search nearest LineStrings to Polygons, and so on. When using more complex geometries as input (e.g. LineStrings or Polygons), the nearest neighbor search uses spatial index, i.e. it creates bounding boxes around the input geometries and inserts them into an R-Tree which is used to make the search queries more efficient. However, the distance between the nearest neighbours is measured based on the true shapes of the geometric features. In the following, we demonstrate how to conduct nearest neighbor analysis with more complex geometries, such as Polygons and LineStrings.</p>
<p>As a real-life case, we first aim to find the closest urban park to building polygons in a neighborhood called Kamppi, which is located in Helsinki, Finland. Then, we aim to find the closest drivable road (LineString) to each building. Let’s start by reading the data and visualize it on a map:</p>
<!-- #endregion -->
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">geopandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">gpd</span>

<span class="n">buildings</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="s2">&quot;data/Helsinki/Kamppi_buildings.gpkg&quot;</span><span class="p">)</span>
<span class="n">parks</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="s2">&quot;data/Helsinki/Kamppi_parks.gpkg&quot;</span><span class="p">)</span>
<span class="n">roads</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="s2">&quot;data/Helsinki/Kamppi_roads.gpkg&quot;</span><span class="p">)</span>
<span class="n">buildings</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Plot buildings, parks and roads</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">buildings</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="s2">&quot;gray&quot;</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">parks</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;green&quot;</span><span class="p">)</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">roads</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">)</span>
</pre></div>
</div>
<!-- #region editable=true slideshow={"slide_type": ""} -->
<p><em><strong>Figure 6.49</strong>. A map showing the buildings with gray color and the parks (green) in the neighborhood of Kamppi, Helsinki.</em></p>
<p>Similarly as finding the nearest neighbor using Points as input data, we can use the <code class="docutils literal notranslate"><span class="pre">.sjoin_nearest()</span></code> to find nearest neighbor between two Polygon datasets. Here, we find the nearest park for each building Polygon and store the distance into the column <code class="docutils literal notranslate"><span class="pre">distance</span></code>:</p>
<!-- #endregion -->
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">nearest_parks</span> <span class="o">=</span> <span class="n">buildings</span><span class="o">.</span><span class="n">sjoin_nearest</span><span class="p">(</span><span class="n">parks</span><span class="p">,</span> <span class="n">distance_col</span><span class="o">=</span><span class="s2">&quot;distance&quot;</span><span class="p">)</span>
<span class="n">nearest_parks</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Maximum distance:&quot;</span><span class="p">,</span> <span class="n">nearest_parks</span><span class="p">[</span><span class="s2">&quot;distance&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Average distance:&quot;</span><span class="p">,</span> <span class="n">nearest_parks</span><span class="p">[</span><span class="s2">&quot;distance&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
<!-- #region editable=true slideshow={"slide_type": ""} -->
<p>Now we have found the nearest park for each building, and as we can see on average the closest park seem to be 61 meters away from the buildings while the longest distance from one of the buildings to the closest park seems to be 229 meters. In a similar manner, we can also find the nearest road from each building as follows:</p>
<!-- #endregion -->
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">nearest_roads</span> <span class="o">=</span> <span class="n">buildings</span><span class="o">.</span><span class="n">sjoin_nearest</span><span class="p">(</span><span class="n">roads</span><span class="p">,</span> <span class="n">distance_col</span><span class="o">=</span><span class="s2">&quot;distance&quot;</span><span class="p">)</span>
<span class="n">nearest_roads</span>
</pre></div>
</div>
<!-- #region editable=true slideshow={"slide_type": ""} -->
<p>As a result, we now have found the nearest road for each building. We have now 703 rows of data which means that for some buildings there have been more than one road that are exactly the same distance apart. To better understand how the spatial join between the buildings and roads have been conducted, we can again visualize the nearest neighbors with a straight line. To do this, we first bring the geometries from the <code class="docutils literal notranslate"><span class="pre">roads</span></code> <code class="docutils literal notranslate"><span class="pre">GeoDataFrame</span></code> into the same table with the buildings:</p>
<!-- #endregion -->
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">nearest_roads</span> <span class="o">=</span> <span class="n">nearest_roads</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
    <span class="n">roads</span><span class="p">[[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]],</span> <span class="n">left_on</span><span class="o">=</span><span class="s2">&quot;index_right&quot;</span><span class="p">,</span> <span class="n">right_index</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span>
<span class="n">nearest_roads</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<!-- #region editable=true slideshow={"slide_type": ""} -->
<p>Now we have the <code class="docutils literal notranslate"><span class="pre">geometry_x</span></code> column representing the building geometries and the <code class="docutils literal notranslate"><span class="pre">geometry_y</span></code> column representing the road geometries (LineStrings). To visualize the connecting lines between buildings and roads, we first need to create geometries that connect the building and closest road geometry from the locations where the distance is shortest. To do this, we can take advantage of a handy function called <code class="docutils literal notranslate"><span class="pre">shortest_line()</span></code> from the <code class="docutils literal notranslate"><span class="pre">shapely</span></code> library that returns a LineString object between the input geometries showing the shortest distance between them. Based on these, we can create a connecting line between a given building and the closest road. Finally, we create a new <code class="docutils literal notranslate"><span class="pre">GeoDataFrame</span></code> called <code class="docutils literal notranslate"><span class="pre">connectors</span></code> out of these lines and also store the length of the <code class="docutils literal notranslate"><span class="pre">LineString</span></code>s as a separate column:</p>
<!-- #endregion -->
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">shapely</span><span class="w"> </span><span class="kn">import</span> <span class="n">shortest_line</span>


<span class="c1"># Generate LineString between nearest points of two geometries</span>
<span class="n">connectors</span> <span class="o">=</span> <span class="n">nearest_roads</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
    <span class="k">lambda</span> <span class="n">row</span><span class="p">:</span> <span class="n">shortest_line</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;geometry_x&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;geometry_y&quot;</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
<span class="p">)</span>

<span class="c1"># Create a new GeoDataFrame out of these geometries</span>
<span class="n">connectors</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">({</span><span class="s2">&quot;geometry&quot;</span><span class="p">:</span> <span class="n">connectors</span><span class="p">},</span> <span class="n">crs</span><span class="o">=</span><span class="n">roads</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span>
<span class="n">connectors</span><span class="p">[</span><span class="s2">&quot;distance&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">connectors</span><span class="o">.</span><span class="n">length</span>
<span class="n">connectors</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
<!-- #region editable=true slideshow={"slide_type": ""} -->
<p>Great, now we have a new <code class="docutils literal notranslate"><span class="pre">GeoDataFrame</span></code> that represents the connectors between the buildings and the drivable roads. Finally, we can visualize the buildings, roads and these connectors to better understand the exact points where the distance between a given building and the closest road is shortest:</p>
<!-- #endregion -->
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">m</span> <span class="o">=</span> <span class="n">buildings</span><span class="o">.</span><span class="n">explore</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="s2">&quot;gray&quot;</span><span class="p">,</span> <span class="n">tiles</span><span class="o">=</span><span class="s2">&quot;CartoDB Positron&quot;</span><span class="p">)</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">roads</span><span class="o">.</span><span class="n">explore</span><span class="p">(</span><span class="n">m</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">)</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">connectors</span><span class="o">.</span><span class="n">explore</span><span class="p">(</span><span class="n">m</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;green&quot;</span><span class="p">)</span>
<span class="n">m</span>
</pre></div>
</div>
<!-- #raw editable=true raw_mimetype="" slideshow={"slide_type": ""} tags=["hide-cell"] -->
<p>\adjustimage{max size={0.9\linewidth}{0.9\paperheight}, caption={\emph{\textbf{Figure 6.50}. A map showing the closest road for each building. The LineStrings marked with green color show the exact location where the distance between a given building and the road is shortest.}}, center, nofloat}{../img/figure_6-50.png}
{ \hspace*{\fill} \}</p>
<!-- #endraw -->
<!-- #region editable=true slideshow={"slide_type": ""} -->
<p><em><strong>Figure 6.50</strong>. A map showing the closest road for each building. The LineStrings marked with green color show the exact location where the distance between a given building and the road is shortest.</em></p>
<!-- #endregion -->
<!-- #region editable=true slideshow={"slide_type": ""} tags=["question"] -->
<section id="question-6-11">
<h4>Question 6.11<a class="headerlink" href="#question-6-11" title="Link to this heading">#</a></h4>
<p>What is the closest road to each park? Use the <code class="docutils literal notranslate"><span class="pre">parks</span></code> and <code class="docutils literal notranslate"><span class="pre">roads</span></code> <code class="docutils literal notranslate"><span class="pre">GeoDataFrames</span></code> and follow the approaches presented above to find the closest road to each park. What is the highest (maximum) distance between parks and roads present in our datasets?</p>
<!-- #endregion -->
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># You can use this cell to enter your solution.</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Solution</span>

<span class="c1"># Find the nearest road</span>
<span class="n">nearest_park_roads</span> <span class="o">=</span> <span class="n">parks</span><span class="o">.</span><span class="n">sjoin_nearest</span><span class="p">(</span><span class="n">roads</span><span class="p">,</span> <span class="n">distance_col</span><span class="o">=</span><span class="s2">&quot;distance&quot;</span><span class="p">)</span>

<span class="c1"># What is the maximum distance?</span>
<span class="n">max_dist</span> <span class="o">=</span> <span class="n">nearest_park_roads</span><span class="p">[</span><span class="s2">&quot;distance&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Maximum distance is </span><span class="si">{</span><span class="n">max_dist</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> meters.&quot;</span><span class="p">)</span>
</pre></div>
</div>
<!-- #region editable=true slideshow={"slide_type": ""} tags=["hide-cell"] -->
</section>
</section>
</section>
<section id="k-nearest-neighbor-search">
<h2>K-Nearest Neighbor search<a class="headerlink" href="#k-nearest-neighbor-search" title="Link to this heading">#</a></h2>
<p>Thus far, we have only focused on finding the nearest neighbor to a given geometry. However, quite commonly you might want to find not only the closest geometry, but a specific number of closest geometries to a given location (1st closest, 2nd closest, and so on). For example, you might be interested to find 3-5 closest public transport stops from your home, because these stops might provide alternative connections to different parts of the city. Doing these kind of queries is a common procedure and a prerequisite for many data analysis techniques, and the technique is commonly called as <em><span class="xref std std-term">K-Nearest Neighbors search</span></em> (or KNN search). Next, we will learn how to find <em>k</em> number of closest neighbors based on two <code class="docutils literal notranslate"><span class="pre">GeoDataFrames</span></code>. We will first aim to find the three nearest public transport stops for each building in the Helsinki Region, and then we will see how to make a <em><a class="reference internal" href="../../../back-matter/nb/glossary.html#term-Radius-query"><span class="xref std std-term">radius query</span></a></em> to find all neighbors within specific distance apart from a given location. K-Nearest Neighbor search techniques are also typically built on top of <em><a class="reference internal" href="../../../back-matter/nb/glossary.html#term-Spatial-index"><span class="xref std std-term">spatial indices</span></a></em> to make the queries more efficient. Previously, with <code class="docutils literal notranslate"><span class="pre">sjoin_nearest()</span></code>, we used an <code class="docutils literal notranslate"><span class="pre">R-tree</span></code> index structure to efficiently find the nearest neighbor for any kind of geometry. However, because the R-tree implementation in Python only supports finding the closest neighbor (a limitation in the underlying GEOS software), we need to use another tree structure called <em><a class="reference internal" href="../../../back-matter/nb/glossary.html#term-KD-Tree"><span class="xref std std-term">KD-Tree</span></a></em> (K-dimensional tree) that can provide us information about K-nearest neighbors (i.e. not only the closest). KD-tree is similar to R-tree, but the data is ordered and sorted in a bit different manner (see Appendices for further details).</p>
<p>In Python, we can conduct KNN search between Point datasets using the <code class="docutils literal notranslate"><span class="pre">scipy</span></code> library. Before we can do the actual query, we need to build the <code class="docutils literal notranslate"><span class="pre">KD-Tree</span></code> spatial index. In scipy, we can use the <code class="docutils literal notranslate"><span class="pre">KDTree</span></code> to build the spatial index which is available from the <code class="docutils literal notranslate"><span class="pre">scipy.spatial</span></code> submodule. The <code class="docutils literal notranslate"><span class="pre">KDTree</span></code> has been implemented in C-language which makes it very fast. In the following, we use the <code class="docutils literal notranslate"><span class="pre">building_points</span></code> and <code class="docutils literal notranslate"><span class="pre">stops</span></code> <code class="docutils literal notranslate"><span class="pre">GeoDataFrames</span></code> that we already used earlier to find three closest public transport stops for each building. Let’s start by reading the data and reproject the data into a metric coordinate reference system (EPSG:3067) so that the distances will be presented as meters:</p>
<!-- #endregion -->
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">geopandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">gpd</span>

<span class="c1"># Read the files and reproject to EPSG:3067</span>
<span class="n">stops</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="s2">&quot;data/Helsinki/pt_stops_helsinki.gpkg&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">epsg</span><span class="o">=</span><span class="mi">3067</span><span class="p">)</span>
<span class="n">building_points</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="s2">&quot;data/Helsinki/building_points_helsinki.zip&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span>
    <span class="n">epsg</span><span class="o">=</span><span class="mi">3067</span>
<span class="p">)</span>

<span class="n">building_points</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">stops</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">stops</span><span class="o">.</span><span class="n">shape</span>
</pre></div>
</div>
<p>As we see, both datasets include Point geometries representing specific buildings and public transport stops (n=8377).</p>
<p>As a first step, we need to build a <code class="docutils literal notranslate"><span class="pre">KDTRee</span></code> index structure based on the Point coordinates. The <code class="docutils literal notranslate"><span class="pre">KDTree</span></code> class expects the Point coordinates to be in <code class="docutils literal notranslate"><span class="pre">array</span></code> format, i.e. not as shapely <code class="docutils literal notranslate"><span class="pre">Point</span></code> objects which we have stored in the <code class="docutils literal notranslate"><span class="pre">geometry</span></code> column. Luckily, it is very easy to convert the shapely geometries into <code class="docutils literal notranslate"><span class="pre">numpy.array</span></code> format by chaining a method <code class="docutils literal notranslate"><span class="pre">.get_coordinates()</span></code> with the <code class="docutils literal notranslate"><span class="pre">.to_numpy()</span></code> method as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">building_coords</span> <span class="o">=</span> <span class="n">building_points</span><span class="o">.</span><span class="n">get_coordinates</span><span class="p">()</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
<span class="n">stop_coords</span> <span class="o">=</span> <span class="n">stops</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">get_coordinates</span><span class="p">()</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>

<span class="n">stop_coords</span>
</pre></div>
</div>
<p>By running these commands, the <code class="docutils literal notranslate"><span class="pre">.get_coordinates()</span></code> method first returns a DataFrame with <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> coordinates as columns, and the <code class="docutils literal notranslate"><span class="pre">.to_numpy()</span></code> method then converts this data into a numpy <code class="docutils literal notranslate"><span class="pre">array</span></code> as we see above. The <code class="docutils literal notranslate"><span class="pre">stop_coords</span></code> variable now contains an array of coordinate tuples (x and y coordinates) which we can pass to the <code class="docutils literal notranslate"><span class="pre">KDTree</span></code> class and create a KD-Tree index structure as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial</span><span class="w"> </span><span class="kn">import</span> <span class="n">KDTree</span>

<span class="n">stop_kdt</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">stop_coords</span><span class="p">)</span>
<span class="n">stop_kdt</span>
</pre></div>
</div>
<p>Now we have initialized a <code class="docutils literal notranslate"><span class="pre">KDTree</span></code> index structure by populating it with stop coordinates. By doing this, we can make very efficient queries to find out which of the ~8000 stops is closest to specific buildings. To do this, we can use the <code class="docutils literal notranslate"><span class="pre">.query()</span></code> method which goes through all the input coordinates (i.e. buildings) and very quickly calculates which of them is the closest, 2nd closest etc. The method returns the distances to the K-number of nearest neighbors as well as the index of the closest <code class="docutils literal notranslate"><span class="pre">stop</span></code> to the given building. By passing an argument <code class="docutils literal notranslate"><span class="pre">k=3</span></code>, we can specify that we want to find three closest neighbors for each building:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Find the three nearest neighbors from stop KD-Tree for each building</span>
<span class="n">k_nearest_dist</span><span class="p">,</span> <span class="n">k_nearest_ix</span> <span class="o">=</span> <span class="n">stop_kdt</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">building_coords</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

<span class="nb">len</span><span class="p">(</span><span class="n">k_nearest_dist</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">stop_kdt.query()</span></code> call returns us two objects. The first one which we store to variable <code class="docutils literal notranslate"><span class="pre">k_nearest_dist</span></code> represents an array/list of distances from each building (n=158 731) to the three of the closest public transport stops in the data. The second variable <code class="docutils literal notranslate"><span class="pre">k_nearest_ix</span></code> represents the index values of the three nearest stops for each building:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Distances to 3 nearest stops</span>
<span class="n">k_nearest_dist</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Index values of the 3 nearest stops</span>
<span class="n">k_nearest_ix</span>
</pre></div>
</div>
<p>Based on these arrays, we can see that the closest stop to the first building in our data is 92.7 meters away from the building, while the second and third closest stops are approximately 460 meters away from the given building. By looking at the index values in the <code class="docutils literal notranslate"><span class="pre">k_nearest_ix</span></code> variable, we can see that the stops with indices 1131, 1135 and 1125 seem to be the three closest public transport stops to the first building in our data.</p>
<p>Now we have successfully computed the K-nearest neighbors between the buildings and the stops. Next, we will attach this information back to our <code class="docutils literal notranslate"><span class="pre">GeoDataFrame</span></code> so that it is easier to do further analyses with the data and create some nice maps out of the data. The data which is returned by the <code class="docutils literal notranslate"><span class="pre">stop_kdt.query()</span></code> command comes out as an array of lists, where each item (list) contains three values that show the distances between three nearest stops and the given building. To be able to easily merge this data with the original <code class="docutils literal notranslate"><span class="pre">GeoDataFrame</span></code> containing the building data, we need to transpose our arrays. After the transpose, the data will be restructured in a way that there will be three arrays and each of these arrays contains the distances/stop-ids for all the buildings in a single list. To transpose a numpy array, we can use the method <code class="docutils literal notranslate"><span class="pre">.T</span></code> which does the trick:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">k_nearest_ix</span><span class="o">.</span><span class="n">T</span>
</pre></div>
</div>
<p>By following this approach, we can store the index and distance information as columns into our <code class="docutils literal notranslate"><span class="pre">GeoDataFrame</span></code> containing values for the 1-3 nearest stops. In the following, we first create a clean copy of the <code class="docutils literal notranslate"><span class="pre">building_points</span></code> <code class="docutils literal notranslate"><span class="pre">GeoDataFrame</span></code> into variable <code class="docutils literal notranslate"><span class="pre">k_nearest</span></code>, which we will then populate with three new columns for the stop indices, and three columns for the distances to the 1-3 closest stops. To access the information for the closest stop, we can call <code class="docutils literal notranslate"><span class="pre">.T[0]</span></code>, while the <code class="docutils literal notranslate"><span class="pre">.T[1]</span></code> and <code class="docutils literal notranslate"><span class="pre">.T[2]</span></code> returns the information for the second and third closest stops accordingly:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Make a copy</span>
<span class="n">k_nearest</span> <span class="o">=</span> <span class="n">building_points</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

<span class="c1"># Add indices of nearest stops</span>
<span class="n">k_nearest</span><span class="p">[</span><span class="s2">&quot;1st_nearest_idx&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">k_nearest_ix</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">k_nearest</span><span class="p">[</span><span class="s2">&quot;2nd_nearest_idx&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">k_nearest_ix</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">k_nearest</span><span class="p">[</span><span class="s2">&quot;3rd_nearest_idx&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">k_nearest_ix</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

<span class="c1"># Add distances</span>
<span class="n">k_nearest</span><span class="p">[</span><span class="s2">&quot;1st_nearest_dist&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">k_nearest_dist</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">k_nearest</span><span class="p">[</span><span class="s2">&quot;2nd_nearest_dist&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">k_nearest_dist</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">k_nearest</span><span class="p">[</span><span class="s2">&quot;3rd_nearest_dist&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">k_nearest_dist</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">k_nearest</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
<p>Perfect! Now we have stored the information for each building about the indices and distances to the three of the closest stops around given buildings. To make this information easier to understand, we can make a nice map that shows the closest three stops for each building. To do this, we can follow a similar approach as we used earlier when visualizing the results from the <code class="docutils literal notranslate"><span class="pre">sjoin_nearest()</span></code> function. Namely, we bring the geometry from the k-nearest stops and connect the building Points with the given stop Points with a LineString. Then it is easy to visualize the closest stops for each building. In the following, we create three separate <code class="docutils literal notranslate"><span class="pre">GeoDataFrames</span></code> that correspond to the nearest, second nearest and third nearest stops from the buildings. We start by storing the <code class="docutils literal notranslate"><span class="pre">stop_index</span></code> as a column which allows us to easily merge the data between <code class="docutils literal notranslate"><span class="pre">stops</span></code> and <code class="docutils literal notranslate"><span class="pre">k_nearest</span></code> (buildings) GeoDataFrames. For making the table join, we can use the pandas <code class="docutils literal notranslate"><span class="pre">.merge()</span></code> function in which we use the <code class="docutils literal notranslate"><span class="pre">1st_nearest_idx</span></code>,  <code class="docutils literal notranslate"><span class="pre">2nd_nearest_idx</span></code> and <code class="docutils literal notranslate"><span class="pre">3rd_nearest_idx</span></code> as the key on the left <code class="docutils literal notranslate"><span class="pre">GeoDataFrame</span></code>, while the <code class="docutils literal notranslate"><span class="pre">stop_index</span></code> is the key on the right <code class="docutils literal notranslate"><span class="pre">GeoDataFrame</span></code>. We also pass the <code class="docutils literal notranslate"><span class="pre">suffixes=('',</span> <span class="pre">'_knearest)</span></code> argument to the <code class="docutils literal notranslate"><span class="pre">.merge()</span></code> method to specify that the column names on the left-side <code class="docutils literal notranslate"><span class="pre">GeoDataFrame</span></code> should stay as they are, while the column names on the right-side will get a suffix <code class="docutils literal notranslate"><span class="pre">_knearest</span></code> in case there are identical column names present in both <code class="docutils literal notranslate"><span class="pre">GeoDataFrames</span></code> (which we have as both frames contain the <code class="docutils literal notranslate"><span class="pre">geometry</span></code> column. Let’s see how we can create these three <code class="docutils literal notranslate"><span class="pre">GeoDataFrames</span></code> and store them into <code class="docutils literal notranslate"><span class="pre">k_nearest_1</span></code>, <code class="docutils literal notranslate"><span class="pre">k_nearest_2</span></code> and <code class="docutils literal notranslate"><span class="pre">k_nearest_3</span></code> variables:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Store the stop index for making the table join</span>
<span class="n">stops</span><span class="p">[</span><span class="s2">&quot;stop_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stops</span><span class="o">.</span><span class="n">index</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Merge the geometries of the nearest stops to the GeoDataFrame</span>
<span class="n">k_nearest_1</span> <span class="o">=</span> <span class="n">k_nearest</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
    <span class="n">stops</span><span class="p">[[</span><span class="s2">&quot;stop_index&quot;</span><span class="p">,</span> <span class="s2">&quot;geometry&quot;</span><span class="p">]],</span>
    <span class="n">left_on</span><span class="o">=</span><span class="s2">&quot;1st_nearest_idx&quot;</span><span class="p">,</span>
    <span class="n">right_on</span><span class="o">=</span><span class="s2">&quot;stop_index&quot;</span><span class="p">,</span>
    <span class="n">suffixes</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot;_knearest&quot;</span><span class="p">),</span>
<span class="p">)</span>
<span class="n">k_nearest_1</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Merge the geometries of the 2nd nearest stops to the GeoDataFrame</span>
<span class="n">k_nearest_2</span> <span class="o">=</span> <span class="n">k_nearest</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
    <span class="n">stops</span><span class="p">[[</span><span class="s2">&quot;stop_index&quot;</span><span class="p">,</span> <span class="s2">&quot;geometry&quot;</span><span class="p">]],</span>
    <span class="n">left_on</span><span class="o">=</span><span class="s2">&quot;2nd_nearest_idx&quot;</span><span class="p">,</span>
    <span class="n">right_on</span><span class="o">=</span><span class="s2">&quot;stop_index&quot;</span><span class="p">,</span>
    <span class="n">suffixes</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot;_knearest&quot;</span><span class="p">),</span>
<span class="p">)</span>
<span class="n">k_nearest_2</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Merge the geometries of the 3rd nearest stops to the GeoDataFrame</span>
<span class="n">k_nearest_3</span> <span class="o">=</span> <span class="n">k_nearest</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
    <span class="n">stops</span><span class="p">[[</span><span class="s2">&quot;stop_index&quot;</span><span class="p">,</span> <span class="s2">&quot;geometry&quot;</span><span class="p">]],</span>
    <span class="n">left_on</span><span class="o">=</span><span class="s2">&quot;3rd_nearest_idx&quot;</span><span class="p">,</span>
    <span class="n">right_on</span><span class="o">=</span><span class="s2">&quot;stop_index&quot;</span><span class="p">,</span>
    <span class="n">suffixes</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot;_knearest&quot;</span><span class="p">),</span>
<span class="p">)</span>
<span class="n">k_nearest_3</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<!-- #region editable=true slideshow={"slide_type": ""} -->
<p>Excellent, now we have merged the stop geometries into the <code class="docutils literal notranslate"><span class="pre">geometry_knearest</span></code> columns. By comparing the values in the <code class="docutils literal notranslate"><span class="pre">stop_index</span></code> column of the <code class="docutils literal notranslate"><span class="pre">GeoDataFrames</span></code> <code class="docutils literal notranslate"><span class="pre">k_nearest_1</span></code>, <code class="docutils literal notranslate"><span class="pre">k_nearethe</span> <span class="pre">st_2</span></code> and <code class="docutils literal notranslate"><span class="pre">k_nearest_3</span></code>, we can see that the values change correctly following the values in <code class="docutils literal notranslate"><span class="pre">1st_</span></code>, <code class="docutils literal notranslate"><span class="pre">2nd_</span></code> and <code class="docutils literal notranslate"><span class="pre">3rd_nearest_index</span></code> column accordingly. The geometries stored in the <code class="docutils literal notranslate"><span class="pre">geometry_knearest</span></code> also have different values in all of the <code class="docutils literal notranslate"><span class="pre">GeoDataFrames</span></code> which is as expected. Now we can create <code class="docutils literal notranslate"><span class="pre">LineString</span></code> geometries connecting these <code class="docutils literal notranslate"><span class="pre">Point</span></code> objects to each other which allows us to create a nice map out of our nearest neighbors and thus better understand the data:</p>
<!-- #endregion -->
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">shapely</span><span class="w"> </span><span class="kn">import</span> <span class="n">LineString</span>

<span class="c1"># Generate LineStrings connecting the building point and K-nearest neighbor</span>
<span class="n">k_nearest_1</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">k_nearest_1</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
    <span class="k">lambda</span> <span class="n">row</span><span class="p">:</span> <span class="n">LineString</span><span class="p">([</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;geometry_knearest&quot;</span><span class="p">]]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
<span class="p">)</span>
<span class="n">k_nearest_2</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">k_nearest_2</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
    <span class="k">lambda</span> <span class="n">row</span><span class="p">:</span> <span class="n">LineString</span><span class="p">([</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;geometry_knearest&quot;</span><span class="p">]]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
<span class="p">)</span>
<span class="n">k_nearest_3</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">k_nearest_3</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
    <span class="k">lambda</span> <span class="n">row</span><span class="p">:</span> <span class="n">LineString</span><span class="p">([</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;geometry_knearest&quot;</span><span class="p">]]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
<span class="p">)</span>

<span class="n">k_nearest_1</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>Now we have updated the <code class="docutils literal notranslate"><span class="pre">geometry</span></code> column of our datasets with <code class="docutils literal notranslate"><span class="pre">LineString</span></code> geometries connecting the building Point with the nearest stop geometries. Next, it is easy to visualize the closest three stops for each building. Because there are thousands of connections in our data, in the following, we select a specific building and the closest stops from that building. The <code class="docutils literal notranslate"><span class="pre">name</span></code> column contains information about the names of the buildings which we can use to choose a building of our interest for visualization:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Find unique building names</span>
<span class="n">k_nearest</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
</pre></div>
</div>
<p>As we can see, one of the buildings is called <code class="docutils literal notranslate"><span class="pre">Hartwall</span> <span class="pre">Arena</span></code> which is an interesting example because it is a large sports arena that is reached by thousands of people via public transport whenever there is some event happening. Thus, let’s filter the data for that building and create an interactive map out of the results, showing the three closest stops indicated with different colors:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Visualize 3 nearest stops to</span>
<span class="n">selected_name</span> <span class="o">=</span> <span class="s2">&quot;Hartwall Arena&quot;</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">k_nearest_1</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">k_nearest_1</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">selected_name</span><span class="p">]</span><span class="o">.</span><span class="n">explore</span><span class="p">(</span>
    <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="n">tiles</span><span class="o">=</span><span class="s2">&quot;CartoDB Positron&quot;</span><span class="p">,</span> <span class="n">max_zoom</span><span class="o">=</span><span class="mi">16</span>
<span class="p">)</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">k_nearest_2</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">k_nearest_2</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">selected_name</span><span class="p">]</span><span class="o">.</span><span class="n">explore</span><span class="p">(</span><span class="n">m</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;orange&quot;</span><span class="p">)</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">k_nearest_3</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">k_nearest_3</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">selected_name</span><span class="p">]</span><span class="o">.</span><span class="n">explore</span><span class="p">(</span><span class="n">m</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;blue&quot;</span><span class="p">)</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">stops</span><span class="o">.</span><span class="n">explore</span><span class="p">(</span><span class="n">m</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;green&quot;</span><span class="p">)</span>
<span class="n">m</span>
</pre></div>
</div>
<!-- #raw editable=true raw_mimetype="" slideshow={"slide_type": ""} tags=["hide-cell"] -->
<p>\adjustimage{max size={0.9\linewidth}{0.9\paperheight}, caption={\emph{\textbf{Figure 6.51}. A map showing the three closest public transport stops to the selected building (Hartwall Arena). The LineString marked with red color show the closest stop, while the line indicated with blue color shows the 3rd closest stop.}}, center, nofloat}{../img/figure_6-51.png}
{ \hspace*{\fill} \}</p>
<!-- #endraw -->
<!-- #region editable=true slideshow={"slide_type": ""} -->
<p><em><strong>Figure 6.51</strong>. A map showing the three closest public transport stops to the selected building (Hartwall Arena). The LineString marked with red color show the closest stop, while the line indicated with blue color shows the 3rd closest stop.</em></p>
<p>From the map, we can see that the closest stops to the arena seem to be located close to a large road 100-130 meters away from the arena, while the third closest stop is closer to the rail roads 377 meters away (Euclidean distance) from the building.</p>
<!-- #endregion -->
<!-- #region editable=true slideshow={"slide_type": ""} -->
<section id="nearest-neighbors-within-radius">
<h3>Nearest neighbors within radius<a class="headerlink" href="#nearest-neighbors-within-radius" title="Link to this heading">#</a></h3>
<p>As a last example related to nearest neighbors we show how to find all neighbors of a given Point geometry within a specific distance threshold. As a practical example, we aim to find and calculate the number of buildings that are within 200 meters from a given public transport stop. Doing this kind of nearest neighbor query is similar to the one that we did with <code class="docutils literal notranslate"><span class="pre">.sjoin_nearest()</span></code> using the <code class="docutils literal notranslate"><span class="pre">max_distance</span></code> parameter, but here we aim to efficiently retrieve all neighbors within the given search radius, not only the closest one which is how <code class="docutils literal notranslate"><span class="pre">sjoin_nearest()</span></code> operates. Finding all neighbors within a specific search radius can also be done using the KD-Tree spatial index. However, in this case we actually build the <code class="docutils literal notranslate"><span class="pre">KDTree</span></code> index for both datasets (buildings and stops) and then use a <code class="docutils literal notranslate"><span class="pre">.query_ball_tree()</span></code> method to find all neighbors within the radius <code class="docutils literal notranslate"><span class="pre">r</span></code>:</p>
<!-- #endregion -->
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial</span><span class="w"> </span><span class="kn">import</span> <span class="n">KDTree</span>

<span class="c1"># Build KDTree indices</span>
<span class="n">stop_kdt</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">stop_coords</span><span class="p">)</span>
<span class="n">building_kdt</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">building_coords</span><span class="p">)</span>

<span class="c1"># Find the three nearest neighbors from stop KD-Tree for each building</span>
<span class="n">k_nearest_ix</span> <span class="o">=</span> <span class="n">stop_kdt</span><span class="o">.</span><span class="n">query_ball_tree</span><span class="p">(</span><span class="n">building_kdt</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">len</span><span class="p">(</span><span class="n">k_nearest_ix</span><span class="p">)</span>
</pre></div>
</div>
<!-- #region -->
<p>Now we have found all the building points within 200 meters from the stops (n=8377). As a result, we get a list of building index values for each stop. The following shows all the indices for the first stop at index 0:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">k_nearest_ix</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="mi">1129</span><span class="p">,</span>
 <span class="mi">1130</span><span class="p">,</span>
 <span class="mi">1155</span><span class="p">,</span>
 <span class="mi">2054</span><span class="p">,</span>
 <span class="mi">2055</span><span class="p">,</span>
 <span class="mi">2056</span><span class="p">,</span>
<span class="o">...</span> <span class="p">(</span><span class="n">output</span> <span class="n">truncated</span><span class="p">)</span>
</pre></div>
</div>
<!-- #endregion -->
<p>Now we can easily store the building indices as a new column to the <code class="docutils literal notranslate"><span class="pre">stops</span></code> <code class="docutils literal notranslate"><span class="pre">GeoDataFrame</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">stops</span><span class="p">[</span><span class="s2">&quot;building_ids_within_range&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">k_nearest_ix</span>
<span class="n">stops</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
<p>With this information, we can for example calculate the number of buildings within 200 meters from each stop. To do this, we can create a simple <code class="docutils literal notranslate"><span class="pre">lambda</span></code> function that checks the length of the id-list and store the result into column <code class="docutils literal notranslate"><span class="pre">building_cnt</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">stops</span><span class="p">[</span><span class="s2">&quot;building_cnt&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stops</span><span class="p">[</span><span class="s2">&quot;building_ids_within_range&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
    <span class="k">lambda</span> <span class="n">id_list</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">id_list</span><span class="p">)</span>
<span class="p">)</span>
<span class="n">stops</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Max number of buildings:&quot;</span><span class="p">,</span> <span class="n">stops</span><span class="p">[</span><span class="s2">&quot;building_cnt&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Average number of buildings:&quot;</span><span class="p">,</span> <span class="n">stops</span><span class="p">[</span><span class="s2">&quot;building_cnt&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<p>By calculating simple statistics from the <code class="docutils literal notranslate"><span class="pre">building_cnt</span></code> column, we can see that on average there are 32.2 buildings within 200 meters from the public transport stops and the maximum number of buildings within this distance is whopping 181 buildings. This indicates very dense neighborhood having numerous buildings in a small area. To better understand, where this kind of neighborhood is located and what does it look like, we can make a map by selecting the rows with highest number of buildings and then plotting the stop and building points within radius:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">filtered</span> <span class="o">=</span> <span class="n">stops</span><span class="p">[</span><span class="s2">&quot;building_cnt&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">stops</span><span class="p">[</span><span class="s2">&quot;building_cnt&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
<span class="n">building_ids</span> <span class="o">=</span> <span class="n">stops</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">filtered</span><span class="p">]</span><span class="o">.</span><span class="n">building_ids_within_range</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">stops</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">filtered</span><span class="p">]</span><span class="o">.</span><span class="n">explore</span><span class="p">(</span>
    <span class="n">tiles</span><span class="o">=</span><span class="s2">&quot;CartoDB Positron&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="n">marker_kwds</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;radius&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">},</span> <span class="n">max_zoom</span><span class="o">=</span><span class="mi">16</span>
<span class="p">)</span>
<span class="n">building_points</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">building_ids</span><span class="p">]</span><span class="o">.</span><span class="n">explore</span><span class="p">(</span><span class="n">m</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
</pre></div>
</div>
<!-- #raw editable=true raw_mimetype="" slideshow={"slide_type": ""} tags=["hide-cell"] -->
<p>\adjustimage{max size={0.9\linewidth}{0.9\paperheight}, caption={\emph{\textbf{Figure 6.52}. A map showing the public transport stop with highest number of buildings surrounding it within 200 meter radius.}}, center, nofloat}{../img/figure_6-52.png}
{ \hspace*{\fill} \}</p>
<!-- #endraw -->
<!-- #region editable=true slideshow={"slide_type": ""} -->
<p><em><strong>Figure 6.52</strong>. A map showing the public transport stop with highest number of buildings surrounding it within 200 meter radius.</em></p>
<p>The map reveals that this stop is indeed located in a densely built neighborhood called Laurinlahti with lots of detached houses. By using a similar approach, it is possible to investigate the urban design and morphology across the city regions which can reveal some interesting patterns and developments relevant to urban planning.</p>
<p>There is also an alternative approach for making a radius query by calculating a buffer around the stop points and then making a spatial join between these Polygon geometries and the buildings. This approach also allows to make queries between other type of geometries than Points.</p>
<!-- #endregion -->
<!-- #region editable=true slideshow={"slide_type": ""} tags=["question"] -->
<section id="question-6-12">
<h4>Question 6.12<a class="headerlink" href="#question-6-12" title="Link to this heading">#</a></h4>
<p>Test and try to find all buildings within 200 meters from the transit stops by creating a 200 meter buffer around the stops and then making a spatial join between the buffers and building points. Calculate the number of buildings per stop_id. Did it take longer to find the nearest buildings using this approach?</p>
<!-- #endregion -->
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># You can use this cell to enter your solution.</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Solution</span>

<span class="c1"># Create a 200 meter buffer</span>
<span class="n">stop_buffer</span> <span class="o">=</span> <span class="n">stops</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">stop_buffer</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stops</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="mi">200</span><span class="p">)</span>

<span class="c1"># Find all the building points intersecting with the buffer</span>
<span class="n">buffer_buildings</span> <span class="o">=</span> <span class="n">stop_buffer</span><span class="o">.</span><span class="n">sjoin</span><span class="p">(</span><span class="n">building_points</span><span class="p">,</span> <span class="n">predicate</span><span class="o">=</span><span class="s2">&quot;intersects&quot;</span><span class="p">)</span>

<span class="c1"># Calculate the number of buildings per stop by grouping</span>
<span class="n">building_count</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">buffer_buildings</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;stop_id&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">stop_name</span><span class="o">.</span><span class="n">count</span><span class="p">()</span><span class="o">.</span><span class="n">to_frame</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
<span class="p">)</span>

<span class="c1"># Now the &quot;stop_name&quot; column contains information about building count, rename</span>
<span class="n">building_count</span> <span class="o">=</span> <span class="n">building_count</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;stop_name&quot;</span><span class="p">:</span> <span class="s2">&quot;building_cnt_buffer&quot;</span><span class="p">})</span>

<span class="c1"># Join the information into the stops</span>
<span class="n">stop_buffer</span> <span class="o">=</span> <span class="n">stop_buffer</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">building_count</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s2">&quot;stop_id&quot;</span><span class="p">)</span>

<span class="c1"># As a result, we should have identical number of buildings identified per stop (see the last two columns)</span>
<span class="n">stop_buffer</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</section>
</section>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "Python-GIS-book/site",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./part2/chapter-06/md"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#nearest-neighbour-analysis-in-python">Nearest neighbour analysis in Python</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#nearest-neighbors-with-polygon-and-linestring-data">Nearest neighbors with Polygon and LineString data</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#question-6-11">Question 6.11</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#k-nearest-neighbor-search">K-Nearest Neighbor search</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#nearest-neighbors-within-radius">Nearest neighbors within radius</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#question-6-12">Question 6.12</a></li>
</ul>
</li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Henrikki Tenkanen, Vuokko Heikinheimo, David Whipp
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2020-2025, Henrikki Tenkanen, Vuokko Heikinheimo, David Whipp.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>