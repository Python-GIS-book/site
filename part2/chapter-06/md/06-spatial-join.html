
<!DOCTYPE html>


<html lang="en" data-content_root="../../../" data-theme="light">

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Spatial join</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "light";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  <!-- 
    this give us a css class that will be invisible only if js is disabled 
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=26a4bc78f4c0ddb94549" rel="stylesheet" />
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=26a4bc78f4c0ddb94549" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=a746c00c" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/sphinx-book-theme.css?v=a3416100" />
    <link rel="stylesheet" type="text/css" href="../../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/css/landing-page.css?v=ca7933c4" />
    <link rel="stylesheet" type="text/css" href="../../../_static/css/custom-toggle-button.css?v=14db4526" />
    <link rel="stylesheet" type="text/css" href="../../../_static/css/custom-text-formatting.css?v=4ef71e6f" />
  
  <!-- So that users can add custom icons -->
  <script src="../../../_static/scripts/fontawesome.js?digest=26a4bc78f4c0ddb94549"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/bootstrap.js?digest=26a4bc78f4c0ddb94549" />
<link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=26a4bc78f4c0ddb94549" />

    <script src="../../../_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="../../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'part2/chapter-06/md/06-spatial-join';</script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="" />
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="light">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="../../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../../../index.html">
  
  
  
  
  
    
    
    
    <img src="../../../_static/pythongis-logo.png" class="logo__image only-light" alt=" - Home"/>
    <img src="../../../_static/pythongis-logo.png" class="logo__image only-dark pst-js-only" alt=" - Home"/>
  
  
</a></div>
        <div class="sidebar-primary-item">

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Part I - Python essentials</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../../part1/index.html">Overview and learning goals</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../part1/chapter-01/index.html">1. Getting started</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-01/nb/0-learning-objectives.html">Learning objectives</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-01/nb/00-motivation.html">1.1 Motivation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-01/nb/01-computers-and-programs.html">1.2 Computers and programs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-01/nb/02-why-python.html">1.3 Why Python?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-01/nb/03-writing-and-running-python-code.html">1.4 Writing and running Python code</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-01/nb/04-using-jupyterlab.html">1.5 Using JupyterLab for writing code</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-01/nb/05-quick-start.html">1.6 Quickly getting started (without installing Python)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-01/nb/06-installation.html">1.7 Installing Python and adding libraries</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../part1/chapter-02/index.html">2. Basic programming concepts</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-02/nb/0-learning-objectives.html">Learning objectives</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-02/nb/00-python-basics.html">2.1 Getting started with Python</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-02/nb/01-lists-and-indices.html">2.2 Lists and indices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-02/nb/02-text-and-numbers.html">2.3 Working with text and numbers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-02/nb/03-for-loops.html">2.4 for loops</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-02/nb/04-conditional-statements.html">2.5 Conditional statements</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-02/nb/05-functions.html">2.6 Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-02/nb/06-writing-scripts.html">2.7 Writing script files</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-02/nb/07-modules.html">2.8 Loading and using modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-02/nb/08-exercises.html">Exercises</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../part1/chapter-03/index.html">3. Introduction to data analysis</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-03/nb/0-learning-objectives.html">Learning objectives</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-03/nb/00-pandas-basics.html">3.1 Getting started with data analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-03/nb/01-data-manipulation.html">3.2 Common tabular operations in pandas</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-03/nb/02-data-analysis.html">3.3 Data wrangling, grouping and aggregation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-03/nb/03-temporal-data.html">3.4 Working with temporal data</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-03/nb/04-exercises.html">Exercises</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../part1/chapter-04/index.html">4. Introduction to data visualization</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-04/nb/0-learning-objectives.html">Learning objectives</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-04/nb/00-plotting-in-python.html">4.1 Plotting in Python</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-04/nb/01-basic-plotting.html">4.2 Plotting with pandas and matplotlib</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-04/nb/02-subplots.html">4.3 Creating subplots</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-04/nb/03-plot-formatting.html">4.4 Effective plot design: line plots</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part1/chapter-04/nb/04-exercises.html">Exercises</a></li>
</ul>
</details></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Part II - Introduction to GIS with Python</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../index.html">Overview and learning goals</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../chapter-05/index.html">5. Getting started</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../chapter-05/nb/0-learning-objectives.html">Learning objectives</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter-05/nb/00-motivation-to-use-python-for-gis.html">5.1 Motivation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter-05/nb/01-introduction-to-geographic-data-in-python.html">5.2 Geographic data in Python</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter-05/nb/02-introduction-to-coordinate-reference-systems.html">5.3 Coordinate reference systems</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../index.html">6. Vector data processing</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../nb/0-learning-objectives.html">Learning objectives</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nb/00-introduction-to-geographic-objects.html">6.1 Representing geographic data in vector format</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nb/01-geodataframe.html">6.2 Introduction to geopandas GeoDataFrames</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nb/02-geometric-operations.html">6.3 Common geometric operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nb/03-coordinate-reference-system.html">6.4 Working with map projections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nb/04-geocoding.html">6.5 Geocoding</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nb/05-spatial-queries.html">6.6 Selecting data based on spatial relationships</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nb/06-spatial-join.html">6.7 Spatial join</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nb/07-nearest-neighbour.html">6.8 Nearest neighbour analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nb/08-overlay-analysis-with-vector-data.html">6.9 Vector overlay operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nb/09-exercises.html">Exercises</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../chapter-07/index.html">7. Raster data processing</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../chapter-07/nb/0-learning-objectives.html">Learning objectives</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter-07/nb/00-introduction-to-raster-data.html">7.1 Representing geographic data in raster format</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter-07/nb/01-data-structures-xarray.html">7.2 Introduction to data structures in xarray</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter-07/nb/02-common-raster-operations.html">7.3 Common raster operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter-07/nb/03-coordinate-reference-systems-raster.html">7.4 Coordinate reference system management</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter-07/nb/04-map-algebra.html">7.5 Map algebra</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter-07/nb/05-data-cubes.html">7.6 Working with data cubes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter-07/nb/06-surface-analysis.html">7.7 Surface analysis</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../chapter-08/index.html">8. Geographic data visualization</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../chapter-08/nb/0-learning-objectives.html">Learning objectives</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter-08/nb/00-introduction-to-geographic-visualization.html">8.1 Introduction to geographic visualization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter-08/nb/01-static-vector-maps.html">8.2 Static maps</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter-08/nb/02-static-raster-maps.html">8.3 Visualizing raster layers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter-08/nb/03-interactive-maps.html">8.4 Interactive maps</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter-08/nb/04-map-design-principles-and-colors.html">8.5 Designing maps</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter-08/nb/05-exercises.html">Exercises</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../chapter-09/index.html">9. Using online geographic data sources</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../chapter-09/nb/0-learning-objectives.html">Learning objectives</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter-09/nb/00-retrieving-osm-data.html">9.1 Retrieving OpenStreetMap data</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter-09/nb/01-retrieving-data-from-wfs.html">9.2 Retrieving data from Web Feature Service (WFS)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter-09/nb/02-retrieving-data-from-wcs.html">9.3 Retrieving data from Web Coverage Service (WCS)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter-09/nb/03-read-data-from-spatial-databases.html">9.4 Reading data from spatial databases</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../chapter-09/nb/04-exercises.html">Exercises</a></li>
</ul>
</details></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Part III - Case studies</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../part3/chapter-10/index.html">10. Spatial interpolation</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../part3/chapter-10/nb/00-introduction-to-spatial-interpolation.html">Introduction to spatial interpolation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part3/chapter-10/nb/01-inverse-distance-weighting.html">Inverse Distance Weighting interpolation with Python</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part3/chapter-10/nb/02-exercises.html">Exercises</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../part3/chapter-11/index.html">11. Spatial network analysis</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../part3/chapter-11/nb/00-introduction-to-spatial-network-analysis.html">Introduction to spatial network analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part3/chapter-11/nb/02-multimodal-spatial-accessibility-modelling.html">Multimodal spatial accessibility analysis with Python</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part3/chapter-11/nb/03-exercises.html">Exercises</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../part3/chapter-12/index.html">12. Terrain analysis</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../part3/chapter-12/nb/00-introduction-to-terrain-analysis.html">Introduction to terrain analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part3/chapter-12/nb/01-interpreting-topographic-features.html">Interpreting topographic features from raster data</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../part3/chapter-12/nb/02-exercises.html">Exercises</a></li>
</ul>
</details></li>
<li class="toctree-l1"><a class="reference internal" href="../../../part3/chapter-13/index.html">13. Conclusions</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Appendices</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../back-matter/appendix-a.html">A. Working effectively in Python</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../back-matter/nb/appendix-0-python-environments.html">Installing and managing Python environments</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../back-matter/nb/appendix-1-best-practices.html">Python programming best practices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../back-matter/nb/appendix-2-git-github.html">Version control with git/GitHub</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../back-matter/nb/appendix-3-script-files.html">Using Python script files</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../back-matter/nb/appendix-4-testing-and-debugging.html">Testing and debugging your code</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../back-matter/appendix-b.html">B. Spatial index efficiency</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../back-matter/nb/appendix-5-spatial-index.html">Spatial index - How to boost spatial queries?</a></li>

</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../back-matter/appendix-c.html">C. Solutions to questions and exercises</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../back-matter/nb/appendix-6-question-solutions.html">Question solutions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../back-matter/nb/appendix-7-exercise-solutions.html">Exercise solutions</a></li>
</ul>
</details></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Back matter</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../../back-matter/nb/acknowledgements.html">Acknowledgements</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../back-matter/nb/glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../back-matter/nb/references.html">References</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../authors.html">About the authors</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Datasets</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../../data/index.html">Data overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../data/noaa-data.html">NOAA Weather data</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">


<a href="https://github.com/Python-GIS-book/site/edit/main/part2/chapter-06/md/06-spatial-join.md" target="_blank"
   class="btn btn-sm btn-source-edit-button"
   title="Suggest edit"
   data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-pencil-alt"></i>
  </span>

</a>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../../../_sources/part2/chapter-06/md/06-spatial-join.md" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.md</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button>


<button class="btn btn-sm pst-navbar-icon search-button search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
</button>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Spatial join</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-basic-logic-of-spatial-join">The basic logic of spatial join</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#spatial-join-with-python">Spatial join with Python</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#preparations-for-spatial-join">Preparations for spatial join</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#join-the-layers-based-on-spatial-relationship">Join the layers based on spatial relationship</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#question-6-10">Question 6.10</a></li>
</ul>
</li>
</ul>
</li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <!-- #region editable=true slideshow={"slide_type": ""} -->
<section class="tex2jax_ignore mathjax_ignore" id="spatial-join">
<h1>Spatial join<a class="headerlink" href="#spatial-join" title="Link to this heading">#</a></h1>
<p>Spatial join is yet another classic GIS task. Retrieving table attributes from one layer and transferring them into another layer based on their spatial relationship is something you most likely need to do on a regular basis when working with geographic data. In the previous section, you learned how to perform spatial queries, such as investigating if a Point is located within a Polygon. We can use this same logic to conduct a spatial join between two layers based on their spatial relationship and transfer the information stored in one layer into the other. We could, for example, join the attributes of a polygon layer into a point layer where each point would get the attributes of a polygon that <code class="docutils literal notranslate"><span class="pre">intersects</span></code> with the point.</p>
<!-- #endregion -->
<!-- #region editable=true slideshow={"slide_type": ""} -->
<section id="the-basic-logic-of-spatial-join">
<h2>The basic logic of spatial join<a class="headerlink" href="#the-basic-logic-of-spatial-join" title="Link to this heading">#</a></h2>
<p>In Figure 6.40, we illustrate the logic of a spatial join by showing how it is possible to combine information between spatial data layers that are located in the same area (i.e. they overlap with each other at least partially). The target here is to combine attribute information of three layers: properties, land use and buildings. Each of these three layers has their own attribute information. Transfering the information between the layers is based on how the individual points in the Properties layer intersect with these layers as shown on the left, i.e. considering different land use areas (commercial, residential, industrial, natural), as well as the building footprints containing a variety of building-related attibute information. On the right, we show the table attributes for these three layers considering the features that intersect with the four Point observations. The table at the bottom shows how the results look after all the attribute data from these layers has been combined into a single table.</p>
<p>It is good to remember that spatial join is always conducted between two layers at a time. Hence, in practice, if we want to make a spatial join between these three layers shown in <strong>Figure 6.37</strong>, we first need to conduct the spatial join between Properties and Land use, and then store this information into an intermediate result. After the first join, we need to make another spatial join between the intermediate result and the third layer (here, the Buildings dataset). After these two separate spatial joins, we have achieved the final result shown at the bottom, showing for each property (row) the corresponding attributes from the land use and building layers as separate columns. In a similar manner, you could also continue joining data (attributes) from other layers as long as you need.</p>
<p><img alt="Figure 6.40. Spatial join allows you to combine attribute information from multiple layers based on spatial relationship." src="../../../_images/spatial-join-basic-idea.png" /></p>
<p><em><strong>Figure 6.40</strong>. Spatial join allows you to combine attribute information from multiple layers based on spatial relationship.</em></p>
<!-- #endregion -->
<!-- #region editable=true slideshow={"slide_type": ""} -->
<p>Now as we understand the basic idea behind the spatial join, let’s continue to learn a bit more about the details of spatial join. Figure 6.41 illustrates how we can do a spatial join between Point and Polygon layers, and how changing specific parameters in the way the join is conducted influence the results. In spatial join, there are two set of options that you can control, which ultimately influence how the data is transferred between the layers. You can control:</p>
<ol class="arabic simple">
<li><p>How the spatial relationship between geometries should be checked (i.e. spatial predicates), and</p></li>
<li><p>What type of table join you want to conduct (inner, left, or right outer join)</p></li>
</ol>
<p>The spatial predicates control how the spatial relationship between the geometries in the two data layers is checked. Only those cases where the spatial predicate returns <code class="docutils literal notranslate"><span class="pre">True</span></code> will be kept in the result. Thus, changing this option (parameter) can have a big influence on your final results after the join. In Figure 6.41 this difference is illustrated at the bottom when you compare the result tables <em>i</em> and <em>ii</em>: In the first table (<em>i</em>) the spatial predicate is <code class="docutils literal notranslate"><span class="pre">within</span></code> that gives us 4 rows that is shown in the table. However, on the second result table (<em>ii</em>), the spatial predicate <code class="docutils literal notranslate"><span class="pre">intersects</span></code> gives us 5 rows. Why is there a difference? This is because the Point with id-number 6 happens to lie exactly at the border of the Polygon C. As you might remember from the  Chapter 6.6, there is a certain difference between these two spatial predicates: The <code class="docutils literal notranslate"><span class="pre">within</span></code> predicate expects that the Point should be inside the Polygon (<code class="docutils literal notranslate"><span class="pre">False</span></code> in our case), whereas <code class="docutils literal notranslate"><span class="pre">intersects</span></code> returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if at least one point is common between the geometries (<code class="docutils literal notranslate"><span class="pre">True</span></code> in our case). In a similar manner, you could change the spatial predicate to <code class="docutils literal notranslate"><span class="pre">contains</span></code>, <code class="docutils literal notranslate"><span class="pre">touches</span></code>, <code class="docutils literal notranslate"><span class="pre">overlaps</span></code> etc. and the result would change accordingly.</p>
<p>It is also important to ensure that the logic for investigating these spatial relationships makes sense when deciding which spatial predicate to use. For example, it would not make any sense to check whether Layer 1 (points) contain the Layer 2 (polygons) because Point objects do not have an interior or boundary, thus lacking the ability to contain any geometric object. Doing this kind of spatial join is possible, but the result from this type of spatial join would always return an empty GeoDataFrame.  However, if we change the spatial join criteria and join the data between layers if the Layer 2 (polygons) contain the Layer 1 (points), this would make a perfect sense, and the query would return rows that match with this criteria.</p>
<p><img alt="Figure 6.41. Different approaches to join two data layers with each other based on spatial relationships." src="../../../_images/spatial-join-alternatives.png" /></p>
<p><em><strong>Figure 6.41</strong>. Different approaches to join two data layers with each other based on spatial relationships.</em></p>
<!-- #endregion -->
<!-- #region editable=true slideshow={"slide_type": ""} -->
<p>The other parameter that you can use to control how the spatial join is conducted is the spatial join type. There are three different join types that influence the outcome of the spatial join:</p>
<ol class="arabic simple">
<li><p><a class="reference internal" href="../../../back-matter/nb/glossary.html#term-Inner-join"><span class="xref std std-term">inner join</span></a></p></li>
<li><p><a class="reference internal" href="../../../back-matter/nb/glossary.html#term-Left-outer-join"><span class="xref std std-term">left outer join</span></a></p></li>
<li><p><a class="reference internal" href="../../../back-matter/nb/glossary.html#term-Right-outer-join"><span class="xref std std-term">right outer join</span></a></p></li>
</ol>
<p>The terms left and right correspond to the two data layers/tables used in the spatial join, and specifically to the order how these layers are used in the spatia join. In our case, the Layer 1 represents always the <code class="docutils literal notranslate"><span class="pre">left</span></code> side of spatial join (indicated with green background color in the tables), whereas the Layer 2 corresponds to the <code class="docutils literal notranslate"><span class="pre">right</span></code> accordingly (white background). When looking at the result tables <em>i</em> and <em>ii</em> (Figure 6.41), we can see that both spatial joins have been conducted using an <code class="docutils literal notranslate"><span class="pre">inner</span> <span class="pre">join</span></code>. When using the <code class="docutils literal notranslate"><span class="pre">inner</span> <span class="pre">join</span></code>, we only keep such rows from the right and left tables that have received <code class="docutils literal notranslate"><span class="pre">True</span></code> after testing the relationship based on the chosen spatial predicate. The result table <em>iii</em> shows an example of <code class="docutils literal notranslate"><span class="pre">left</span> <span class="pre">outer</span> <span class="pre">join</span></code> in which all the rows from the left are kept (no matter what), and the ones from the right that have a match based on spatial predicate will be added to the result. In case some of the rows on the left do not have a match with the right layer, those attributes will receive NaN (No data) as the attribute value as shown with Point id 3 and 6 in the result table <em>iii</em>. The <code class="docutils literal notranslate"><span class="pre">right</span> <span class="pre">outer</span> <span class="pre">join</span></code> works in quite a similar manner, but in this case the values on the right layer are always kept (no matter what), and only the ones from the left that have a match based on the spatial predicate will be kept. The rows without a match will receive a Nan (No data) on the left side as shown in result table <em>iv</em> with Polygon that has a Name D.</p>
<p>With these two parameters (spatial predicate and join type), it is possible to conduct many kind of spatial joins. Commonly the <code class="docutils literal notranslate"><span class="pre">inner</span> <span class="pre">join</span></code> using the <code class="docutils literal notranslate"><span class="pre">intersect</span></code> as a spatial predicate is the one that you want to use, but depending on your needs there are various options where to choose from.</p>
<!-- #endregion -->
</section>
<section id="spatial-join-with-python">
<h2>Spatial join with Python<a class="headerlink" href="#spatial-join-with-python" title="Link to this heading">#</a></h2>
<!-- #region editable=true slideshow={"slide_type": ""} -->
<p>Now as we have learned the basic logic of spatial join, let’s see how we can do it in Python. Spatial join can be done easily with geopandas using the <code class="docutils literal notranslate"><span class="pre">.sjoin()</span></code> method. Next, we will learn how to use this method to perform a spatial join between two layers: 1) <code class="docutils literal notranslate"><span class="pre">addresses</span></code> which are the locations that we geocoded in the Chapter 6.5, and 2) <code class="docutils literal notranslate"><span class="pre">population</span> <span class="pre">grid</span></code> which is a 250m x 250m grid polygon layer that contains population information from the Helsinki Region (source: Helsinki Region Environmental Services Authority). Let’s start by reading the data:</p>
<!-- #endregion -->
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">geopandas</span> <span class="k">as</span> <span class="nn">gpd</span>

<span class="n">addr_fp</span> <span class="o">=</span> <span class="s2">&quot;data/Helsinki/addresses.shp&quot;</span>
<span class="n">addresses</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">addr_fp</span><span class="p">)</span>
<span class="n">addresses</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>As we can see, the <code class="docutils literal notranslate"><span class="pre">addresses</span></code> GeoDataFrame contains address Points which represent a selection of public transport stations in the Helsinki Region.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">pop_grid_fp</span> <span class="o">=</span> <span class="s2">&quot;data/Helsinki/Population_grid_2021_HSY.gpkg&quot;</span>
<span class="n">pop_grid</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">pop_grid_fp</span><span class="p">)</span>
<span class="n">pop_grid</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">pop_grid</span></code> dataset contains few columns, namely a unique <code class="docutils literal notranslate"><span class="pre">id</span></code>, the number of <code class="docutils literal notranslate"><span class="pre">inhabitants</span></code> per grid cell, and the <code class="docutils literal notranslate"><span class="pre">occupancy_rate</span></code> as percentage.</p>
<!-- #region editable=true slideshow={"slide_type": ""} -->
<section id="preparations-for-spatial-join">
<h3>Preparations for spatial join<a class="headerlink" href="#preparations-for-spatial-join" title="Link to this heading">#</a></h3>
<p>As a first step before making a spatial join, it is always good to check that the coordinate reference system (CRS) of the layers are identical. The basic requirement for a successful spatial join is that the layers should overlap with each other in space. If the geometries between the layers do not share the same CRS, it is very likely that the spatial join will fail and produces an empty GeoDataFrame. By looking at the numbers in the <code class="docutils literal notranslate"><span class="pre">geometry</span></code> column of the <code class="docutils literal notranslate"><span class="pre">addresses</span></code> and <code class="docutils literal notranslate"><span class="pre">pop_grid</span></code> GeoDataFrames above, it is fairly evident that the datasets are in different coordinate reference system as the numbers seem to differ a lot. Let’s check the CRS information of each layer:</p>
<!-- #endregion -->
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Address points CRS:&quot;</span><span class="p">,</span> <span class="n">addresses</span><span class="o">.</span><span class="n">crs</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Population grid CRS:&quot;</span><span class="p">,</span> <span class="n">pop_grid</span><span class="o">.</span><span class="n">crs</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
</pre></div>
</div>
<!-- #region editable=true slideshow={"slide_type": ""} -->
<p>We can further verify that the crs are indeed not the same.</p>
<!-- #endregion -->
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">addresses</span><span class="o">.</span><span class="n">crs</span> <span class="o">==</span> <span class="n">pop_grid</span><span class="o">.</span><span class="n">crs</span>
</pre></div>
</div>
<!-- #region editable=true slideshow={"slide_type": ""} -->
<p>To fix this issue, let’s reproject the geometries in the <code class="docutils literal notranslate"><span class="pre">addresses</span></code> GeoDataFrame to the same CRS as <code class="docutils literal notranslate"><span class="pre">pop_grid</span></code> using the <code class="docutils literal notranslate"><span class="pre">.to_crs()</span></code> method which was introduced in Chapter 6.4. To ensure that we will have exactly the same CRS in both layers, we can use the <code class="docutils literal notranslate"><span class="pre">pop_grid.crs</span></code> attribute information as the input for the <code class="docutils literal notranslate"><span class="pre">crs</span></code> parameter:</p>
<!-- #endregion -->
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Reproject</span>
<span class="n">addresses</span> <span class="o">=</span> <span class="n">addresses</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">crs</span><span class="o">=</span><span class="n">pop_grid</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span>

<span class="c1"># Validate match</span>
<span class="n">addresses</span><span class="o">.</span><span class="n">crs</span> <span class="o">==</span> <span class="n">pop_grid</span><span class="o">.</span><span class="n">crs</span>
</pre></div>
</div>
<!-- #region editable=true slideshow={"slide_type": ""} -->
<p>Good, now the datasets share the same coordinate reference system. As a last preparatory step, let’s visualize both datasets on top of each other to see how the inhabitants are distributed over the region, and how the address points are located in relation to the grid:</p>
<!-- #endregion -->
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Plot the population data classified into 5 classes</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">pop_grid</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
    <span class="n">column</span><span class="o">=</span><span class="s2">&quot;inhabitants&quot;</span><span class="p">,</span>
    <span class="n">cmap</span><span class="o">=</span><span class="s2">&quot;Greens&quot;</span><span class="p">,</span>
    <span class="n">scheme</span><span class="o">=</span><span class="s2">&quot;naturalbreaks&quot;</span><span class="p">,</span>
    <span class="n">k</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
    <span class="n">legend</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">legend_kwds</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;loc&quot;</span><span class="p">:</span> <span class="s2">&quot;lower right&quot;</span><span class="p">},</span>
    <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span>
<span class="p">)</span>

<span class="c1"># Add address points on top using blue &quot;Diamond&quot; markers</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">addresses</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;blue&quot;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;D&quot;</span><span class="p">)</span>
</pre></div>
</div>
<!-- #region editable=true slideshow={"slide_type": ""} -->
<p><em><strong>Figure 6.42</strong>. Prerequisite for a successful spatial join: The Polygon layer overlaps with the Point layer.</em></p>
<p>As we can see from the map in Figure 6.42, the Polygons representing the population distribution in the area now overlap nicely with the address locations and we are ready to join information among these two layers based on their spatial relationship.</p>
<!-- #endregion -->
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># This cell sets the number of lines of pandas output to a maximum of 7</span>
<span class="c1"># The cell is removed when building the website/book PDF</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

<span class="n">pd</span><span class="o">.</span><span class="n">set_option</span><span class="p">(</span><span class="s2">&quot;display.max_rows&quot;</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
</pre></div>
</div>
<!-- #region editable=true slideshow={"slide_type": ""} -->
</section>
<section id="join-the-layers-based-on-spatial-relationship">
<h3>Join the layers based on spatial relationship<a class="headerlink" href="#join-the-layers-based-on-spatial-relationship" title="Link to this heading">#</a></h3>
<p>After the preparatory steps, we are ready to perform the spatial join between our two data layers. The aim here is to get information about <em>How many people live in a given polygon that contains an individual address-point</em>? Thus, we want to join the attribute information from the <code class="docutils literal notranslate"><span class="pre">pop_grid</span></code> layer into the <code class="docutils literal notranslate"><span class="pre">addresses</span></code> Point layer using the <code class="docutils literal notranslate"><span class="pre">.sjoin()</span></code> method. As we saw in the beginning of Chapter 6.7, there are different ways to conduct spatial join by adjusting the <a class="reference internal" href="../../../back-matter/nb/glossary.html#term-Spatial-predicate"><span class="xref std std-term">spatial predicate</span></a> and join-type options. Controlling the spatial predicate in the <code class="docutils literal notranslate"><span class="pre">.sjoin()</span></code> can be done using the <code class="docutils literal notranslate"><span class="pre">predicate</span></code> parameter. The most commonly used options for the <code class="docutils literal notranslate"><span class="pre">predicate</span></code> parameter are:</p>
<ul class="simple">
<li><p>“intersects” (the default option)</p></li>
<li><p>“contains”</p></li>
<li><p>“covered_by”</p></li>
<li><p>“covers”</p></li>
<li><p>“crosses”</p></li>
<li><p>“overlaps”</p></li>
<li><p>“touches”</p></li>
<li><p>“within’</p></li>
</ul>
<p>The join type, as we learned earlier, is the second option to control how the data will be merged. In <code class="docutils literal notranslate"><span class="pre">.sjoin()</span></code> method, this can be adjusted with the <code class="docutils literal notranslate"><span class="pre">how</span></code> parameter. The possible values for the <code class="docutils literal notranslate"><span class="pre">how</span></code> parameter are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;inner&quot;</span></code> (the default option)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;left&quot;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;right&quot;</span></code></p></li>
</ul>
<!-- #endregion -->
<!-- #region editable=true slideshow={"slide_type": ""} -->
<p>Let’s now join the attributes from the <code class="docutils literal notranslate"><span class="pre">pop_grid</span></code> GeoDataFrame into the <code class="docutils literal notranslate"><span class="pre">addresses</span></code> GeoDataFrame by using the <code class="docutils literal notranslate"><span class="pre">.sjoin()</span></code>. Here, the <code class="docutils literal notranslate"><span class="pre">addresses</span></code> GeoDataFrame containing the points is the one we want to use as a starting point, as this layer is the <em>receiving</em> member of the spatial join. Futhermore, we specify <code class="docutils literal notranslate"><span class="pre">predicate=&quot;within&quot;</span></code> for the spatial predicate as we are interested to know <em>within</em> which Polygon a given Point is located. Finally, we specify the join type with <code class="docutils literal notranslate"><span class="pre">how=&quot;inner&quot;</span></code> which means that only such rows are kept from both layers where the spatial predicate returns <code class="docutils literal notranslate"><span class="pre">True</span></code>. This means that if there are Points that are not inside of any of the Polygons, they will be dropped from the result. Thus, we formulate the command in the following form and store the result in the variable <code class="docutils literal notranslate"><span class="pre">join</span></code>:</p>
<!-- #endregion -->
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">join</span> <span class="o">=</span> <span class="n">addresses</span><span class="o">.</span><span class="n">sjoin</span><span class="p">(</span><span class="n">pop_grid</span><span class="p">,</span> <span class="n">predicate</span><span class="o">=</span><span class="s2">&quot;within&quot;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;inner&quot;</span><span class="p">)</span>
<span class="n">join</span>
</pre></div>
</div>
<!-- #region editable=true slideshow={"slide_type": ""} -->
<p>Awesome! Now we have performed a successful spatial join that gave us as a result 31 rows and four new columns. Most importantly, we received information about <code class="docutils literal notranslate"><span class="pre">inhabitants</span></code> and <code class="docutils literal notranslate"><span class="pre">occupancy_rate</span></code> which correspond to the number of inhabitants and occupancy rate in the cell where the address-point is located. In addition, we got columns <code class="docutils literal notranslate"><span class="pre">index_right</span></code> and <code class="docutils literal notranslate"><span class="pre">id_right</span></code> which tell the index and id of the matching polygon in the right-side member of the spatial join (i.e. population grid). As you see, also the <code class="docutils literal notranslate"><span class="pre">id</span></code> column in the left-side member of the spatial join was renamed as <code class="docutils literal notranslate"><span class="pre">id_left</span></code>. The suffices <code class="docutils literal notranslate"><span class="pre">_left</span></code> and <code class="docutils literal notranslate"><span class="pre">_right</span></code> are appended to the column names to differentiate the columns in cases where there are identical column names present in both GeoDataFrames.</p>
<p>Let’s also visualize the joined output. In the following, we plot the points using the <code class="docutils literal notranslate"><span class="pre">inhabitants</span></code> column to indicate the color:</p>
<!-- #endregion -->
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">ax</span> <span class="o">=</span> <span class="n">join</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
    <span class="n">column</span><span class="o">=</span><span class="s2">&quot;inhabitants&quot;</span><span class="p">,</span>
    <span class="n">cmap</span><span class="o">=</span><span class="s2">&quot;Reds&quot;</span><span class="p">,</span>
    <span class="n">markersize</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span>
    <span class="n">scheme</span><span class="o">=</span><span class="s2">&quot;quantiles&quot;</span><span class="p">,</span>
    <span class="n">legend</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span>
<span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Amount of inhabitants living close to the point&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p><em><strong>Figure 6.43</strong>. Amount of population living close to the addresses can be visualized after a successful spatial join with the population grid.</em></p>
<p>As we see from the map, the number of population living close to the stations vary quite significantly ranging from 43 up to 1409 inhabitants. As a last thing after the spatial join, it is useful to investigate if we lost any data while doing the spatial join. Let’s check this by comparing the number of rows in our result to how many addresses we had originally:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">len</span><span class="p">(</span><span class="n">addresses</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">join</span><span class="p">)</span>
</pre></div>
</div>
<p>As we can see, there seems to be three Points that were located outside of the populated grid cells. If we plot the layers on top of each other as an interactive map, we can investigate where the points outside of polygons are located:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">m</span> <span class="o">=</span> <span class="n">pop_grid</span><span class="o">.</span><span class="n">explore</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="s2">&quot;blue&quot;</span><span class="p">,</span> <span class="n">style_kwds</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="s2">&quot;blue&quot;</span><span class="p">,</span> <span class="n">stroke</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
<span class="n">addresses</span><span class="o">.</span><span class="n">explore</span><span class="p">(</span><span class="n">m</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">)</span>
</pre></div>
</div>
<!-- #raw editable=true slideshow={"slide_type": ""} tags=["hide-cell"] raw_mimetype="" -->
<p>\adjustimage{max size={0.9\linewidth}{0.9\paperheight}, caption={\emph{\textbf{Figure 6.44}. An interactive map of the two layers reveal that some points are located outside of the Polygons.}}, center, nofloat}{../img/figure_6-44.png}
{ \hspace*{\fill} \}</p>
<!-- #endraw -->
<!-- #region editable=true slideshow={"slide_type": ""} -->
<p><em><strong>Figure 6.44</strong>. An interactive map of the two layers reveal that some points are located outside of the Polygons.</em></p>
<p>From <strong>Figure 6.44</strong>, we can see that some points are located outside of polygons in the areas close to the railway lines and the motorway. Is this a problem? It depends, but in certain cases, you might want to keep the information for the points that did not get a match based on the spatial relationship. We can achieve this by changing the <code class="docutils literal notranslate"><span class="pre">how</span></code> parameter into <code class="docutils literal notranslate"><span class="pre">left</span></code>, which keeps every row from the left member of the spatial join even when no match is found from the other layer:</p>
<!-- #endregion -->
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># This cell sets the number of lines of pandas output to a maximum of 7</span>
<span class="c1"># The cell is removed when building the website/book PDF</span>
<span class="n">pd</span><span class="o">.</span><span class="n">set_option</span><span class="p">(</span><span class="s2">&quot;display.max_rows&quot;</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">left_join</span> <span class="o">=</span> <span class="n">addresses</span><span class="o">.</span><span class="n">sjoin</span><span class="p">(</span><span class="n">pop_grid</span><span class="p">,</span> <span class="n">predicate</span><span class="o">=</span><span class="s2">&quot;within&quot;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>
<span class="n">left_join</span>
</pre></div>
</div>
<p>Now the result in the <code class="docutils literal notranslate"><span class="pre">left_join</span></code> contains all the original 34 addresses. Let’s investigate a bit more to see which rows did not have a matching polygon in the population grid. After a left-join, those rows that do not have a matching geometry in the right-side member of the join are filled with NaN values. Thus, we should be able to locate them easily by searching for rows that do not have any values e.g. in the <code class="docutils literal notranslate"><span class="pre">inhabitants</span></code> column that was part of the <code class="docutils literal notranslate"><span class="pre">pop_grid</span></code> GeoDataFrame. We can do this by doing a selection using the <code class="docutils literal notranslate"><span class="pre">.isnull()</span></code> method:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">left_join</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">left_join</span><span class="p">[</span><span class="s2">&quot;inhabitants&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isnull</span><span class="p">()]</span>
</pre></div>
</div>
<!-- #region editable=true slideshow={"slide_type": ""} -->
<p>The result from this query reveals the exact locations of the points that miss information in the last four columns of the GeoDataFrame. Okay, but is this all we can do? In some cases, it can be crucial that all features in the target layer would get information from the other dataset even if the spatial predicate between the geometries would not match perfectly. Sometimes fetching information from another layer based on the closest geometry up to a certain distance threshold can be considered sufficient for making a spatial join. Luckily, we can achieve this with relative ease using geopandas which we will learn next.</p>
<!-- #endregion -->
<!-- #region editable=true slideshow={"slide_type": ""} tags=["question"] -->
<section id="question-6-10">
<h4>Question 6.10<a class="headerlink" href="#question-6-10" title="Link to this heading">#</a></h4>
<p>Do the spatial join another way around, i.e. make a spatial join where you join information from the address points into the population grid. How does the result differ from the version where we joined information from the grids to the points? What would be the benefit of doing the join this way around?</p>
<!-- #endregion -->
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># You can use this cell to enter your solution.</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Solution</span>

<span class="c1"># Join information from address points to the grid</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">pop_grid</span><span class="o">.</span><span class="n">sjoin</span><span class="p">(</span><span class="n">addresses</span><span class="p">)</span>

<span class="c1"># Check the structure</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>

<span class="c1"># Visualize the result</span>
<span class="n">result</span><span class="o">.</span><span class="n">explore</span><span class="p">()</span>

<span class="c1"># see reflection about this solution in the back matter</span>
</pre></div>
</div>
</section>
</section>
</section>
</section>


                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
                <dialog id="pst-secondary-sidebar-modal"></dialog>
                <div id="pst-secondary-sidebar" class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-basic-logic-of-spatial-join">The basic logic of spatial join</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#spatial-join-with-python">Spatial join with Python</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#preparations-for-spatial-join">Preparations for spatial join</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#join-the-layers-based-on-spatial-relationship">Join the layers based on spatial relationship</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#question-6-10">Question 6.10</a></li>
</ul>
</li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Henrikki Tenkanen, Vuokko Heikinheimo, David Whipp
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2020-2024, Henrikki Tenkanen, Vuokko Heikinheimo, David Whipp.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="../../../_static/scripts/bootstrap.js?digest=26a4bc78f4c0ddb94549"></script>
<script defer src="../../../_static/scripts/pydata-sphinx-theme.js?digest=26a4bc78f4c0ddb94549"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>